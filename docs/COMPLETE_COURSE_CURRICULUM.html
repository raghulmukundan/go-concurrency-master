<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Go Concurrency Mastery: Complete Course Curriculum - Go Concurrency Course</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Source+Serif+4:opsz,wght@8..60,400;8..60,500;8..60,600;8..60,700&family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css" class="hljs-theme" data-theme="light">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css" class="hljs-theme" data-theme="dark" disabled>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/go.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/bash.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/marked/12.0.0/marked.min.js"></script>
<link rel="stylesheet" href="./style.css">
</head>
<body>

<header class="header">
  <button class="menu-toggle" onclick="toggleMobile()">&#9776;</button>
  <div class="header-brand">
    <div class="header-logo">Go</div>
    <span class="header-title">Go Concurrency</span>
    <div class="header-sep"></div>
    <span class="header-part-title" id="headerPart">Select a section to begin</span>
  </div>
  <div class="section-nav" id="sectionNav" style="display:none">
    <button class="nav-btn" id="prevSection" onclick="prevSlide()">&#8249;</button>
    <span class="section-indicator" id="sectionIndicator">1 / 1</span>
    <button class="nav-btn" id="nextSection" onclick="nextSlide()">&#8250;</button>
  </div>
  <div class="header-right">
    <button class="nav-btn font-btn" onclick="changeFontSize(-1)" title="Decrease font size">A&#8722;</button>
    <button class="nav-btn font-btn" onclick="changeFontSize(1)" title="Increase font size">A+</button>
    <button class="nav-btn" id="darkToggle" onclick="toggleDark()" title="Toggle dark mode"><span id="darkIcon">&#9789;</span></button>
    <button class="nav-btn" title="Toggle sidebar" onclick="toggleSidebar()" style="font-size:14px">&#9776;</button>
  </div>
</header>

<div class="layout">
  <nav class="sidebar" id="sidebar">
    <div id="sidebarContent">
      <div class="loading"><div class="spinner"></div><div class="loading-text">Loading...</div></div>
    </div>
  </nav>

  <div class="main" id="mainArea">
    <div class="sections-container" id="sectionsContainer">
      <div class="welcome" id="welcomeScreen">
        <div class="welcome-icon">Go</div>
        <h1>Go Concurrency Mastery</h1>
        <p>A hands-on course to master concurrent programming in Go. Navigate sections horizontally with arrow keys or buttons.</p>
        <button class="welcome-btn" onclick="loadFirst()">Start Reading</button>
        <a class="welcome-btn resume-btn" id="resumeBtn" style="display:none" href="#">Continue Reading</a>
        <div class="welcome-hint">Use &#8592; &#8594; arrow keys to navigate sections</div>
      </div>
    </div>
    <div class="section-dots" id="sectionDots"></div>
  </div>
</div>

<script>
var __BASE_PATH__ = ".";
var __PAGE_ID__ = "_overview/COMPLETE_COURSE_CURRICULUM.md";
var __PAGE_CONTENT__ = "# Go Concurrency Mastery: Complete Course Curriculum\n## 100% Problem-First, Beginner-to-Expert Progression\n\n**Version**: 2.0 (Enhanced with Beginner-Friendly Structure + Distributed Systems)  \n**Last Updated**: January 2026  \n**Total Duration**: 150-200 hours for complete mastery\n\n---\n\n## Course Philosophy\n\n**Learning Method**: PROBLEM ‚Üí CODE ‚Üí BREAK ‚Üí FIX ‚Üí UNDERSTAND ‚Üí MASTER\n\nEvery chapter follows this proven structure:\n1. **Real Problem** - Something you'd build in production\n2. **Sequential/Naive Solution** - Simple code that works (or breaks)\n3. **Watch It Break** - See failures in action\n4. **Deep Understanding** - WHY it broke, with visuals and analogies\n5. **Fix It Multiple Ways** - Different solutions with trade-offs\n6. **Go Deep** - How it works internally (beginner-friendly)\n7. **Practice Problems** - 10-30 exercises per chapter\n8. **Production Considerations** - Real-world usage\n\n**No theory lectures. Just code that teaches.**\n\n---\n\n# PART 1: SINGLE-PROCESS CONCURRENCY\n\nMaster Go's concurrency primitives within one program before tackling distributed systems.\n\n---\n\n## Chapter 1: The Race Condition Crisis ‚≠ê TEMPLATE CHAPTER\n\n**Problem**: Build a web analytics URL hit counter  \n**Duration**: 10-14 hours for mastery  \n**Difficulty**: Beginner  \n**Practice Problems**: 15\n\n### Section Breakdown (9 Parts, 70+ Sections)\n\n#### Part 0: Introduction (10 min)\n- 0.1: What We're Building\n- 0.2: The Challenge\n- 0.3: Our Learning Journey\n- 0.4: What You'll Learn\n- 0.5: How to Use This Chapter\n- 0.6: Prerequisites Check\n- 0.7: A Note on Learning\n\n#### Part 1: The Sequential Baseline (30 min)\n- 1.1: The Problem Statement\n- 1.2: Sequential Implementation (complete code)\n- 1.3: Running the Code\n- 1.4: Measuring Performance\n- 1.5: Understanding the Bottleneck\n- 1.6: Stop and Think (quizzes)\n- 1.7: What's Next\n\n#### Part 2: Breaking It - Naive Concurrent Version (40 min)\n- 2.1: Let's Make It Concurrent!\n- 2.2: What Are Goroutines? (from basics)\n- 2.3: Naive Concurrent Implementation\n- 2.4: Running the Broken Code\n- 2.5: The Race Detector\n- 2.6: Understanding the Output\n- 2.7: Exercises\n\n#### Part 3: What IS a Race Condition? Deep Dive (60 min)\n- 3.1: Understanding Operations (read-modify-write)\n- 3.2: The Lost Update Problem (with timeline)\n- 3.3: Memory and Caches (beginner-friendly)\n- 3.4: The Three Conditions for a Race\n- 3.5: Types of Races\n- 3.6: Practice Identifying Races (10 examples)\n\n#### Part 4: Solution #1 - Channels (120 min)\n- 4.1: What IS a Channel? (conceptual)\n- 4.2: Your First Channel\n- 4.3: Channels Block!\n- 4.4: Buffered Channels\n- 4.5: Buffered vs Unbuffered\n- 4.6: Channel-Based Counter Solution\n- 4.7: How Does This Prevent the Race?\n- 4.8: Closing Channels\n- 4.9: Ranging Over Channels\n- 4.10: How Channels Work (simplified internals)\n- 4.11: Channel Performance\n- 4.12: When to Use Channels\n- 4.13: Common Channel Patterns\n- 4.14: Common Mistakes\n- 4.15: Exercises (15 problems)\n\n#### Part 5: Solution #2 - Mutexes (120 min)\n- 5.1: What IS a Mutex? (conceptual)\n- 5.2: Your First Mutex\n- 5.3: The Critical Section\n- 5.4: Why defer Unlock()?\n- 5.5: Mutex-Based Counter Solution\n- 5.6: How Does Mutex Prevent the Race?\n- 5.7: Locking for Reads Too!\n- 5.8: How Mutexes Work (simplified internals)\n- 5.9: Normal and Starvation Mode\n- 5.10: Mutex Performance\n- 5.11: When to Use Mutexes\n- 5.12: RWMutex - Better for Reads\n- 5.13: Common Mistakes\n- 5.14: Exercises (15 problems)\n\n#### Part 6: Solution #3 - Atomics (80 min)\n- 6.1: What ARE Atomic Operations?\n- 6.2: Your First Atomic\n- 6.3: Atomic Operations Available\n- 6.4: Atomic-Based Counter Solution\n- 6.5: How Atomics Prevent the Race\n- 6.6: CPU-Level Atomics (beginner-friendly)\n- 6.7: Atomic Performance\n- 6.8: When to Use Atomics\n- 6.9: Common Mistakes\n- 6.10: Exercises (10 problems)\n\n#### Part 7: Comparing All Solutions (50 min)\n- 7.1: Side-by-Side Comparison\n- 7.2: Benchmarking All Three\n- 7.3: The Decision Tree\n- 7.4: Production Considerations\n- 7.5: Real-World Examples\n\n#### Part 8: Practice Problems (120 min)\n- Beginner: 5 problems\n- Intermediate: 5 problems\n- Advanced: 5 problems\n\n#### Part 9: Wrap-Up (10 min)\n- 9.1: What You Learned\n- 9.2: Cheat Sheet\n- 9.3: Next Chapter Preview\n\n**Interview Questions Covered**:\n- \"Fix this race condition\" (All FAANG)\n- \"Implement thread-safe counter\" (Google/Meta)\n- \"When to use channels vs mutexes?\" (Amazon/Uber)\n\n---\n\n## Chapter 2: The Deadlock Disaster\n\n**Problem**: Multi-account money transfer system  \n**Duration**: 12-16 hours  \n**Difficulty**: Beginner-Intermediate  \n**Practice Problems**: 18\n\n### What You'll Build\n- Bank account transfers between multiple accounts\n- Discover deadlock (program freezes completely)\n- Three solutions: lock ordering, timeouts, try-lock\n\n### Major Sections\n1. **Introduction \u0026 Sequential Transfers** (30 min)\n2. **Naive Concurrent Transfers** - Deadlock! (40 min)\n3. **What IS a Deadlock?** - Four conditions (60 min)\n4. **Solution #1: Lock Ordering** (60 min)\n5. **Solution #2: Timeout with Select** (60 min)\n6. **Solution #3: Try-Lock Pattern** (60 min)\n7. **Dining Philosophers Problem** (90 min)\n   - Three different solutions\n8. **Detecting Deadlocks** (40 min)\n9. **Practice Problems** (150 min)\n10. **Wrap-Up** (20 min)\n\n**Key Concepts**:\n- Circular wait\n- Hold and wait\n- Coffman conditions\n- Deadlock detection vs prevention\n\n**Interview Questions**:\n- \"Solve Dining Philosophers\" (Amazon/Google)\n- \"Implement safe concurrent transfers\" (Goldman Sachs)\n- \"Detect deadlocks in code\" (Microsoft)\n\n---\n\n## Chapter 3: The Channel Catastrophe\n\n**Problem**: Log processing pipeline (producer-consumer)  \n**Duration**: 14-18 hours  \n**Difficulty**: Intermediate  \n**Practice Problems**: 20\n\n### What You'll Build\n- Log processing pipeline\n- Multiple producers, multiple consumers\n- Channel patterns: fan-out, fan-in, pipelines\n\n### Major Sections\n1. **Introduction \u0026 Sequential Pipeline** (30 min)\n2. **Unbuffered Channels** - No concurrency benefit (40 min)\n3. **Buffered Channels** - Goroutine leaks! (60 min)\n4. **Channel Closing** - Panics and deadlocks (90 min)\n5. **Multiple Producers** - Close panics (60 min)\n6. **Proper Pattern: WaitGroup + Closer** (90 min)\n7. **Fan-Out Pattern** (60 min)\n8. **Fan-In Pattern** (60 min)\n9. **Pipeline Pattern** (90 min)\n10. **Select Statement** (90 min)\n11. **Practice Problems** (180 min)\n12. **Wrap-Up** (30 min)\n\n**Key Concepts**:\n- Channel direction (send-only, receive-only)\n- Select with default\n- Or-channel pattern\n- Done channel pattern\n\n**Interview Questions**:\n- \"Build a worker pool\" (Uber/Netflix)\n- \"Implement pipeline with cancellation\" (Google)\n- \"Fix channel deadlocks\" (Meta/Airbnb)\n\n---\n\n## Chapter 4: The Goroutine Leak Nightmare\n\n**Problem**: HTTP API making concurrent external calls  \n**Duration**: 12-16 hours  \n**Difficulty**: Intermediate  \n**Practice Problems**: 16\n\n### What You'll Build\n- API gateway calling multiple services\n- Memory grows unbounded (leak!)\n- Fix with context and proper cleanup\n\n### Major Sections\n1. **Introduction \u0026 Simple API** (30 min)\n2. **Spawning Goroutines** - Looks fine (40 min)\n3. **Load Testing** - Memory explodes! (60 min)\n4. **Finding Leaks with pprof** (90 min)\n5. **Leak Pattern #1: Blocking Channel** (60 min)\n6. **Leak Pattern #2: HTTP Without Timeout** (60 min)\n7. **Leak Pattern #3: Blocked Select** (60 min)\n8. **Fix with context.Context** (120 min)\n9. **Proper Cleanup Patterns** (90 min)\n10. **Practice Problems** (150 min)\n11. **Wrap-Up** (20 min)\n\n**Key Concepts**:\n- Goroutine lifecycle\n- Context propagation\n- Timeout patterns\n- Cancellation\n\n**Interview Questions**:\n- \"How do you prevent goroutine leaks?\" (All FAANG)\n- \"Implement request timeout\" (Netflix/Stripe)\n- \"Debug this memory leak\" (Uber real code)\n\n---\n\n## Chapter 5: The WaitGroup Wreckage\n\n**Problem**: Coordinate parallel database queries  \n**Duration**: 10-12 hours  \n**Difficulty**: Beginner-Intermediate  \n**Practice Problems**: 14\n\n### What You'll Build\n- Parallel queries to multiple databases\n- Collect results, handle errors\n- errgroup package patterns\n\n### Major Sections\n1. **Introduction \u0026 Sequential Queries** (30 min)\n2. **Firing Goroutines** - Missing results! (40 min)\n3. **WaitGroup Basics** (60 min)\n4. **Common WaitGroup Bugs** (90 min)\n5. **Collecting Results with Channels** (60 min)\n6. **Collecting Results with Mutex** (60 min)\n7. **Error Handling Patterns** (90 min)\n8. **The errgroup Package** (90 min)\n9. **Practice Problems** (120 min)\n10. **Wrap-Up** (20 min)\n\n**Key Concepts**:\n- WaitGroup Add/Done/Wait\n- Error aggregation\n- First error vs all errors\n- errgroup.WithContext\n\n**Interview Questions**:\n- \"Coordinate N parallel operations\" (Google/Amazon)\n- \"Implement parallel error handling\" (Meta)\n- \"Fix WaitGroup bugs\" (Microsoft/Apple)\n\n---\n\n## Chapter 6: The Select Statement Sorcery\n\n**Problem**: Job scheduler with priorities and timeouts  \n**Duration**: 12-14 hours  \n**Difficulty**: Intermediate  \n**Practice Problems**: 17\n\n### What You'll Build\n- Priority job scheduler\n- Timeout handling\n- Cancellation patterns\n\n### Major Sections\n1. **Introduction \u0026 Basic Scheduler** (30 min)\n2. **Multiple Channels** - Select basics (60 min)\n3. **Random Selection** - Not priority! (60 min)\n4. **Priority Select Patterns** (90 min)\n5. **Timeout with time.After** - Memory leak! (90 min)\n6. **Proper Timeout with Timer** (60 min)\n7. **Context Cancellation** (90 min)\n8. **Or-Channel Pattern** (60 min)\n9. **Practice Problems** (150 min)\n10. **Wrap-Up** (20 min)\n\n**Key Concepts**:\n- Select semantics\n- Default case\n- time.After leak\n- Timer.Reset pattern\n\n**Interview Questions**:\n- \"Implement timeout with cancellation\" (Uber/Stripe)\n- \"Build a rate limiter\" (All FAANG + Stripe)\n- \"Fix select performance bug\" (Netflix)\n\n---\n\n## Chapter 7: The Mutex Mayhem\n\n**Problem**: Thread-safe LRU cache for API responses  \n**Duration**: 14-18 hours  \n**Difficulty**: Intermediate-Advanced  \n**Practice Problems**: 19\n\n### What You'll Build\n- LRU cache from scratch\n- Compare single lock, RWMutex, sharded locks\n- Understand lock granularity\n\n### Major Sections\n1. **Introduction \u0026 Naive Map** - Panics! (40 min)\n2. **Single Mutex Solution** (60 min)\n3. **Performance Problem** - Reads block! (60 min)\n4. **RWMutex Solution** (90 min)\n5. **Lock Granularity** (90 min)\n6. **Sharded Map Pattern** (120 min)\n7. **sync.Map Comparison** (60 min)\n8. **Deadlock with Multiple Locks** (90 min)\n9. **Practice Problems** (180 min)\n10. **Wrap-Up** (20 min)\n\n**Key Concepts**:\n- Critical section minimization\n- Read-write locks\n- Lock striping/sharding\n- Deadlock avoidance\n\n**Interview Questions**:\n- \"Implement thread-safe LRU cache\" (Google/Meta/Amazon)\n- \"When RWMutex vs Mutex?\" (All senior roles)\n- \"Design high-concurrency cache\" (Netflix/Uber)\n\n---\n\n## Chapter 8: The Context Confusion\n\n**Problem**: Microservice calling multiple downstream services  \n**Duration**: 12-14 hours  \n**Difficulty**: Intermediate  \n**Practice Problems**: 15\n\n### What You'll Build\n- API aggregator calling 5 services\n- Proper timeout propagation\n- Graceful shutdown\n\n### Major Sections\n1. **Introduction \u0026 Naive Calls** (30 min)\n2. **Cascading Delays** - No cancellation (60 min)\n3. **Context Basics** (90 min)\n4. **WithTimeout, WithDeadline, WithCancel** (120 min)\n5. **Context Propagation** (90 min)\n6. **Request Scoped Values** (60 min)\n7. **Graceful Shutdown Pattern** (120 min)\n8. **Practice Problems** (150 min)\n9. **Wrap-Up** (20 min)\n\n**Key Concepts**:\n- Context tree\n- Cancellation propagation\n- Value context (when to use)\n- Shutdown patterns\n\n**Interview Questions**:\n- \"Implement graceful shutdown\" (All FAANG)\n- \"Handle cancellation across services\" (Uber/Netflix)\n- \"Build timeout hierarchy\" (Google/Stripe)\n\n---\n\n## Chapter 9: The Production Patterns Panic\n\n**Problem**: Production-ready web crawler  \n**Duration**: 16-20 hours  \n**Difficulty**: Advanced  \n**Practice Problems**: 22\n\n### What You'll Build\n- Complete web crawler with:\n  - Worker pools\n  - Rate limiting\n  - Deduplication\n  - Circuit breaker\n  - Metrics\n\n### Major Sections\n1. **Introduction \u0026 Simple Crawler** (40 min)\n2. **Worker Pool Pattern** (120 min)\n3. **Rate Limiter: Token Bucket** (90 min)\n4. **Rate Limiter: Leaky Bucket** (90 min)\n5. **Deduplication** (60 min)\n6. **Circuit Breaker** (120 min)\n7. **Metrics Collection** (90 min)\n8. **Singleflight Pattern** (90 min)\n9. **Practice Problems** (200 min)\n10. **Wrap-Up** (30 min)\n\n**Key Concepts**:\n- Bounded parallelism\n- Backpressure\n- Circuit breaker states\n- Request deduplication\n\n**Interview Questions**:\n- \"Design a web crawler\" (Google classic)\n- \"Implement rate limiter\" (Stripe/Uber/All FAANG)\n- \"Build circuit breaker\" (Netflix/Amazon)\n\n---\n\n## Chapter 10: The Memory Model Mystery\n\n**Problem**: Understanding when writes become visible  \n**Duration**: 10-12 hours  \n**Difficulty**: Advanced  \n**Practice Problems**: 12\n\n### What You'll Build\n- Examples showing memory visibility issues\n- Happens-before relationships\n- Synchronization guarantees\n\n### Major Sections\n1. **Introduction \u0026 Invisible Writes** (40 min)\n2. **The Go Memory Model** (90 min)\n3. **Happens-Before Relationships** (120 min)\n4. **Channel Guarantees** (60 min)\n5. **Mutex Guarantees** (60 min)\n6. **Atomic Guarantees** (60 min)\n7. **Common Memory Model Bugs** (90 min)\n8. **Double-Checked Locking** (60 min)\n9. **Practice Problems** (120 min)\n10. **Wrap-Up** (20 min)\n\n**Key Concepts**:\n- Memory reordering\n- Cache coherence\n- Synchronization points\n- Sequential consistency\n\n**Interview Questions**:\n- \"Explain Go memory model\" (Senior+ all companies)\n- \"Why unexpected behavior?\" (Google/Netflix)\n- \"Implement lock-free counter\" (Systems roles)\n\n---\n\n## Chapter 11: The Performance Profiling Path\n\n**Problem**: Concurrent code slower than sequential!  \n**Duration**: 10-12 hours  \n**Difficulty**: Advanced  \n**Practice Problems**: 13\n\n### What You'll Build\n- Benchmark suite\n- Profile concurrent code\n- Fix bottlenecks\n\n### Major Sections\n1. **Introduction \u0026 Slow Code** (30 min)\n2. **Benchmarking Correctly** (90 min)\n3. **CPU Profiling with pprof** (90 min)\n4. **Mutex Contention Profiling** (90 min)\n5. **False Sharing** (90 min)\n6. **Amdahl's Law** (60 min)\n7. **CPU vs I/O Bound** (60 min)\n8. **GOMAXPROCS Tuning** (60 min)\n9. **Practice Problems** (120 min)\n10. **Wrap-Up** (20 min)\n\n**Key Concepts**:\n- pprof tools\n- Contention analysis\n- Cache line effects\n- Speedup limits\n\n**Interview Questions**:\n- \"Why is concurrent code slow?\" (All senior roles)\n- \"Profile and optimize\" (Google/Meta/Netflix)\n- \"Explain Amdahl's Law\" (Systems design)\n\n---\n\n## Chapter 12: The Debugging Dungeon\n\n**Problem**: Production deadlocks and races  \n**Duration**: 8-10 hours  \n**Difficulty**: Advanced  \n**Practice Problems**: 10\n\n### Major Sections\n1. **Introduction** (20 min)\n2. **Race Detector Deep Dive** (90 min)\n3. **pprof Goroutine Profiling** (90 min)\n4. **Execution Tracing** (90 min)\n5. **Delve for Goroutines** (60 min)\n6. **Testing Concurrent Code** (90 min)\n7. **Practice Problems** (120 min)\n8. **Wrap-Up** (20 min)\n\n**Key Concepts**:\n- Race detector internals\n- Goroutine analysis\n- Execution traces\n- Testing strategies\n\n**Interview Questions**:\n- \"Debug concurrency issues\" (All companies)\n- \"Walk through debugging deadlock\" (Google/Amazon)\n\n---\n\n# PART 2: DISTRIBUTED CONCURRENCY\n\nApply concurrency concepts across multiple services and machines.\n\n---\n\n## Chapter 13: The Cross-Service Catastrophe\n\n**Problem**: Product price aggregator (10 supplier APIs)  \n**Duration**: 12-14 hours  \n**Difficulty**: Intermediate-Advanced  \n**Practice Problems**: 18\n\n### What You'll Build\n- API aggregator\n- Scatter-gather pattern\n- Circuit breaker for services\n- Request hedging\n\n### Major Sections\n1. **Introduction \u0026 Sequential Calls** (30 min)\n2. **Naive Parallel Calls** - Hangs forever! (40 min)\n3. **Goroutine Leaks Across Services** (60 min)\n4. **errgroup.WithContext** (90 min)\n5. **Scatter-Gather Pattern** (90 min)\n6. **Circuit Breaker for Services** (120 min)\n7. **Request Hedging** (90 min)\n8. **Practice Problems** (180 min)\n9. **Wrap-Up** (20 min)\n\n**Key Concepts**:\n- Service orchestration\n- Partial failures\n- Redundant requests\n- Fail-fast patterns\n\n**Interview Questions**:\n- \"Aggregate data from multiple services\" (All FAANG)\n- \"Handle partial failures\" (Netflix/Uber)\n- \"Implement circuit breaker\" (Amazon/Google)\n\n---\n\n## Chapter 14: The Distributed Lock Disaster\n\n**Problem**: Scheduled job runs on 3 servers (duplicates!)  \n**Duration**: 14-16 hours  \n**Difficulty**: Advanced  \n**Practice Problems**: 16\n\n### What You'll Build\n- Distributed lock with Redis\n- Distributed lock with etcd\n- Leader election\n- Lease management\n\n### Major Sections\n1. **Introduction \u0026 Multi-Instance Problem** (40 min)\n2. **File Locking** - Doesn't work! (60 min)\n3. **Redis SETNX** - Lock never expires (60 min)\n4. **Redis with TTL** - Still broken (60 min)\n5. **Redis with Lua Script** (90 min)\n6. **etcd Lease-Based Lock** (120 min)\n7. **Leader Election with etcd** (120 min)\n8. **Handling Split-Brain** (90 min)\n9. **Practice Problems** (180 min)\n10. **Wrap-Up** (30 min)\n\n**Key Concepts**:\n- Distributed coordination\n- Lease semantics\n- Leader election\n- Split-brain scenarios\n\n**Interview Questions**:\n- \"Ensure one instance runs job\" (All FAANG)\n- \"Implement distributed locking\" (Google/Amazon)\n- \"Design leader election\" (Netflix/Uber)\n\n---\n\n## Chapter 15: The Saga Pattern Saga\n\n**Problem**: E-commerce order (Order‚ÜíPayment‚ÜíInventory)  \n**Duration**: 16-20 hours  \n**Difficulty**: Advanced  \n**Practice Problems**: 20\n\n### What You'll Build\n- Saga coordinator\n- Compensating transactions\n- Choreography-based saga\n- Orchestration-based saga\n\n### Major Sections\n1. **Introduction \u0026 Monolithic Transaction** (40 min)\n2. **Microservices Approach** - Inconsistent! (60 min)\n3. **Manual Rollback** - Fails partway (60 min)\n4. **Saga Pattern Introduction** (90 min)\n5. **Compensating Transactions** (120 min)\n6. **Orchestration-Based Saga** (120 min)\n7. **Choreography-Based Saga** (120 min)\n8. **Idempotency** (90 min)\n9. **Outbox Pattern** (90 min)\n10. **Practice Problems** (200 min)\n11. **Wrap-Up** (30 min)\n\n**Key Concepts**:\n- Distributed transactions\n- Eventual consistency\n- Compensation logic\n- State machines\n\n**Interview Questions**:\n- \"Handle distributed transactions\" (All FAANG)\n- \"Explain saga vs 2PC\" (Staff+ everywhere)\n- \"Design order processing\" (Amazon/Uber)\n\n---\n\n## Chapter 16: The Message Queue Madness\n\n**Problem**: Build your own message queue (NSQ/Kafka-like)  \n**Duration**: 20-24 hours  \n**Difficulty**: Advanced  \n**Practice Problems**: 25\n\n### What You'll Build\n- Complete message queue with:\n  - Multiple topics\n  - Consumer groups\n  - Partitioning\n  - Persistence\n  - At-least-once delivery\n\n### Major Sections\n1. **Introduction \u0026 Simple Queue** (40 min)\n2. **Race on Slice** - Corruption! (60 min)\n3. **Mutex Protection** (60 min)\n4. **Multiple Topics** (90 min)\n5. **Buffered Channel Per Topic** (90 min)\n6. **Bounded Buffer** (90 min)\n7. **Consumer Groups** (120 min)\n8. **Partitioning** (120 min)\n9. **Write-Ahead Log** (150 min)\n10. **Backpressure Strategies** (90 min)\n11. **Pub-Sub with Fan-Out** (90 min)\n12. **Practice Problems** (240 min)\n13. **Wrap-Up** (30 min)\n\n**Key Concepts**:\n- Queue internals\n- Partitioning strategies\n- Consumer rebalancing\n- Durability guarantees\n\n**Interview Questions**:\n- \"Design a message queue\" (Google/Amazon classic)\n- \"How Kafka handles concurrency\" (Uber/Netflix)\n- \"Implement pub-sub\" (All FAANG)\n\n---\n\n## Chapter 17: The Tracing Tragedy\n\n**Problem**: Request spans 5 services, can't find bottleneck  \n**Duration**: 10-12 hours  \n**Difficulty**: Intermediate-Advanced  \n**Practice Problems**: 15\n\n### What You'll Build\n- Trace ID propagation\n- Distributed spans\n- OpenTelemetry integration\n- Cross-service debugging\n\n### Major Sections\n1. **Introduction \u0026 Timeout Mystery** (30 min)\n2. **No Tracing** - Impossible to debug (40 min)\n3. **Request ID Basics** (60 min)\n4. **Context Propagation** (90 min)\n5. **Lost in Goroutines** (60 min)\n6. **HTTP Header Propagation** (90 min)\n7. **Message Queue Metadata** (90 min)\n8. **OpenTelemetry Integration** (120 min)\n9. **Distributed Spans** (90 min)\n10. **Practice Problems** (150 min)\n11. **Wrap-Up** (20 min)\n\n**Key Concepts**:\n- Trace context\n- Span lifecycle\n- Sampling strategies\n- Cross-boundary propagation\n\n**Interview Questions**:\n- \"Debug distributed systems\" (All FAANG)\n- \"Implement distributed tracing\" (Google/Netflix)\n- \"Handle context propagation\" (Uber/Stripe)\n\n---\n\n## Chapter 18: The Capstone Project\n\n**Problem**: Complete distributed e-commerce system  \n**Duration**: 30-40 hours  \n**Difficulty**: Expert  \n**Practice Problems**: 30\n\n### What You'll Build\n\n**System Architecture**:\n- Order Service (HTTP)\n- Payment Service (gRPC)\n- Inventory Service (REST)\n- Notification Service (async)\n- Your Message Queue (from Ch 16)\n\n**Features**:\n- Saga-based order flow\n- Distributed tracing (OpenTelemetry)\n- Leader election for jobs\n- Circuit breakers\n- Rate limiting\n- Distributed locking for inventory\n- Graceful shutdown\n- Metrics and health checks\n\n### Major Sections\n1. **Introduction \u0026 Architecture** (60 min)\n2. **Service Skeleton** (120 min)\n3. **Message Queue Integration** (120 min)\n4. **Saga Implementation** (180 min)\n5. **Distributed Tracing** (120 min)\n6. **Leader Election** (120 min)\n7. **Circuit Breakers** (120 min)\n8. **Rate Limiting** (120 min)\n9. **Distributed Locks** (120 min)\n10. **Graceful Shutdown** (120 min)\n11. **Testing Strategy** (180 min)\n12. **Load Testing** (120 min)\n13. **Practice Problems** (360 min)\n14. **Wrap-Up** (60 min)\n\n**This integrates all 17 chapters!**\n\n---\n\n# COURSE STATISTICS\n\n## Time Investment\n\n| Category | Hours |\n|----------|-------|\n| Part 1: Single-Process (Ch 1-12) | 140-180 hours |\n| Part 2: Distributed (Ch 13-17) | 62-76 hours |\n| Part 3: Capstone (Ch 18) | 30-40 hours |\n| **Total Course** | **232-296 hours** |\n\n**Realistic Schedule**:\n- **10 hours/week**: 6-7 months\n- **20 hours/week**: 3-3.5 months\n- **40 hours/week (bootcamp)**: 6-8 weeks\n\n## Content Volume\n\n| Metric | Count |\n|--------|-------|\n| Total Chapters | 18 |\n| Total Sections | 500+ |\n| Practice Problems | 280+ |\n| Interview Questions | 85+ |\n| Code Examples | 300+ |\n| Lines of Code (you'll write) | 25,000+ |\n| Production Patterns | 40+ |\n\n## Difficulty Progression\n\n**Beginner** (Chapters 1-3): 36-48 hours  \n**Intermediate** (Chapters 4-9): 78-100 hours  \n**Advanced** (Chapters 10-12): 26-34 hours  \n**Expert Distributed** (Chapters 13-18): 92-114 hours\n\n---\n\n# LEARNING OBJECTIVES\n\n## By End of Part 1 (Single-Process)\n\nYou will be able to:\n- ‚úÖ Write thread-safe Go code\n- ‚úÖ Identify and fix race conditions\n- ‚úÖ Choose between channels, mutexes, atomics\n- ‚úÖ Debug concurrent programs\n- ‚úÖ Pass L4-L5 concurrency interviews\n- ‚úÖ Build production Go services\n\n## By End of Part 2 (Distributed)\n\nYou will additionally:\n- ‚úÖ Coordinate across multiple services\n- ‚úÖ Implement distributed patterns (saga, locks, queues)\n- ‚úÖ Design distributed systems\n- ‚úÖ Pass Staff+ system design interviews\n- ‚úÖ Build microservice architectures\n\n---\n\n# INTERVIEW PREPARATION\n\n## Companies Covered\n\n**FAANG**: Google, Meta, Amazon, Netflix, Apple  \n**Top Tech**: Microsoft, Uber, Airbnb, Stripe, Twitter  \n**Finance**: Goldman Sachs, JP Morgan, Citadel  \n**Others**: Dropbox, LinkedIn, Salesforce, Cloudflare\n\n## Question Types by Level\n\n**L3-L4 (Junior-Mid)**:\n- Fix race conditions\n- Implement worker pools\n- Use channels correctly\n- Basic mutex patterns\n\n**L5-L6 (Senior)**:\n- Design concurrent systems\n- Optimize performance\n- Debug production issues\n- Choose right primitives\n\n**L7+ (Staff+)**:\n- Distributed systems design\n- Saga patterns\n- Distributed locking\n- Message queue architecture\n\n---\n\n# HOW TO USE THIS COURSE\n\n## Sequential Path (Recommended)\n\n1. **Start Chapter 1** - Foundation for everything\n2. **Complete all exercises** - Don't skip!\n3. **One chapter per week** - Sustainable pace\n4. **Review before moving on** - Ensure mastery\n\n## Accelerated Path\n\n1. **Chapters 1-3** (fundamentals) - 3 weeks\n2. **Chapters 4-9** (patterns) - 6 weeks\n3. **Chapters 10-12** (advanced) - 2 weeks\n4. **Chapters 13-18** (distributed) - 6 weeks\n**Total**: 17 weeks at 15-20 hours/week\n\n## Interview Prep Path\n\n**For L4-L5 roles** (8 weeks):\n- Chapters 1-9 + practice problems\n- Focus on implementation over theory\n- Mock interview every week\n\n**For Staff+ roles** (12 weeks):\n- Full course Chapters 1-18\n- All capstone projects\n- System design practice\n\n## Reference Path\n\nAlready experienced? Use as reference:\n- Jump to specific chapters as needed\n- Use decision trees and cheat sheets\n- Practice problems for weak areas\n\n---\n\n# PREREQUISITES\n\n## Required Knowledge\n\n- ‚úÖ Go basics (variables, functions, structs, loops)\n- ‚úÖ Basic data structures (maps, slices)\n- ‚úÖ Command line comfort\n\n## Helpful But Not Required\n\n- Understanding of HTTP/REST\n- Basic systems knowledge\n- Experience with any concurrent programming\n\n## Setup Requirements\n\n- Go 1.21 or higher\n- Text editor or IDE\n- 8+ GB RAM for running examples\n- Linux/Mac/Windows (all supported)\n\n---\n\n# TEACHING METHODOLOGY\n\n## Every Chapter Follows This Pattern\n\n### 1. Problem Introduction (10-20% of time)\n- Real-world context\n- Why this matters\n- What success looks like\n\n### 2. Naive Implementation (20-30%)\n- Sequential or simple concurrent\n- Watch it break or perform poorly\n- Understand the problem viscerally\n\n### 3. Deep Understanding (20-30%)\n- WHY it broke\n- How the system works\n- Beginner-friendly analogies\n- Visual diagrams\n\n### 4. Solutions (30-40%)\n- Multiple approaches\n- Implementation step-by-step\n- How each works internally\n- Trade-offs\n\n### 5. Practice (30-40% of total time)\n- 10-30 problems per chapter\n- Progressive difficulty\n- Solutions with explanations\n\n## Teaching Techniques Used\n\n**Analogies**: Complex concepts explained with everyday examples  \n**Visuals**: Text-based diagrams and timelines  \n**Progression**: Simple ‚Üí Complex, never overwhelming  \n**Repetition**: Key concepts revisited across chapters  \n**Hands-On**: Code first, theory emerges naturally  \n**Mistakes**: Common errors shown and explained  \n**Quizzes**: Check understanding immediately  \n**Real Code**: Everything is runnable  \n\n---\n\n# WHAT MAKES THIS COURSE UNIQUE\n\n## Compared to Other Go Concurrency Resources\n\n| Feature | This Course | Typical Resources |\n|---------|-------------|-------------------|\n| Approach | Problem-first | Theory-first |\n| Code | 100% runnable | Often pseudocode |\n| Depth | Basics ‚Üí Internals | Surface level OR only advanced |\n| Practice | 280+ problems | Few or none |\n| Time Estimate | Realistic (200+ hrs) | Unrealistic (\"learn in weekend!\") |\n| Distributed Systems | 6 chapters | Rarely covered |\n| Interview Prep | 85+ real questions | Generic advice |\n| Beginner-Friendly | Hand-holding throughout | Assumes expertise |\n\n---\n\n# SUCCESS STORIES (What You'll Achieve)\n\nAfter completing this course, you will have:\n\n**Built Projects**:\n- Thread-safe data structures (counters, caches, queues)\n- Production web crawler\n- Your own message queue\n- Complete distributed e-commerce system\n\n**Passed Interviews At**:\n- FAANG companies\n- Unicorn startups\n- Financial institutions\n- Systems roles\n\n**Contributed To**:\n- Open source Go projects\n- Your company's infrastructure\n- Technical blog posts\n- Teaching others\n\n---\n\n# VERSION HISTORY\n\n**Version 2.0** (January 2026):\n- Added beginner-friendly detailed structure\n- 18 chapters (was 12)\n- Distributed systems coverage (Chapters 13-18)\n- 280+ practice problems (was 200+)\n- Chapter 1 fully expanded as template\n\n**Version 1.0** (Original):\n- 12 chapters on single-process concurrency\n- Problem-first approach established\n- Core curriculum defined\n\n---\n\n# GETTING STARTED\n\n1. **Download the course materials**\n2. **Start with Chapter 1, Part 0** - Introduction\n3. **Set aside 1-2 hours for your first session**\n4. **Join the community** (discussions, questions)\n5. **Commit to the journey** - This takes time!\n\n**Ready? Let's make you a Go concurrency expert!** üöÄ\n\n---\n\n*This curriculum is designed to take you from zero concurrent programming knowledge to Staff+ engineer level over 200-300 hours of deliberate practice. Every concept builds on the previous. Every exercise reinforces learning. Every chapter prepares you for real production systems and technical interviews.*\n\n*The journey is long, but the destination is mastery.*\n";
var __STRUCTURE__ = {"title":"Go Concurrency Mastery","overview":[{"id":"COMPLETE_COURSE_CURRICULUM","title":"Go Concurrency Mastery: Complete Course Curriculum","filename":"COMPLETE_COURSE_CURRICULUM.md"}],"chapters":[{"id":"chapter-01","title":"Chapter 01: The Race Condition Crisis","dir":"chapter-01","parts":[{"id":"PART0_INTRODUCTION","title":"Chapter 1, Part 0: Introduction and Setup","filename":"PART0_INTRODUCTION.md"},{"id":"PART1_SEQUENTIAL_BASELINE","title":"Chapter 1, Part 1: The Sequential Baseline","filename":"PART1_SEQUENTIAL_BASELINE.md"},{"id":"PART3_RACE_CONDITIONS_DEEP_DIVE","title":"Chapter 1, Part 3: What IS a Race Condition? - Deep Dive","filename":"PART3_RACE_CONDITIONS_DEEP_DIVE.md"},{"id":"PART4_SOLUTION_CHANNELS","title":"Chapter 1, Part 4: Solution #1 - Channels","filename":"PART4_SOLUTION_CHANNELS.md"}]}]};
</script>
<script src="./app.js"></script>
</body>
</html>