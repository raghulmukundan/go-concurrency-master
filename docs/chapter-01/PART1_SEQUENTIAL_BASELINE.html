<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Chapter 1, Part 1: The Sequential Baseline - Go Concurrency Course</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Source+Serif+4:opsz,wght@8..60,400;8..60,500;8..60,600;8..60,700&family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css" class="hljs-theme" data-theme="light">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css" class="hljs-theme" data-theme="dark" disabled>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/go.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/bash.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/marked/12.0.0/marked.min.js"></script>
<link rel="stylesheet" href="../style.css">
</head>
<body>

<header class="header">
  <button class="menu-toggle" onclick="toggleMobile()">&#9776;</button>
  <div class="header-brand">
    <div class="header-logo">Go</div>
    <span class="header-title">Go Concurrency</span>
    <div class="header-sep"></div>
    <span class="header-part-title" id="headerPart">Select a section to begin</span>
  </div>
  <div class="section-nav" id="sectionNav" style="display:none">
    <button class="nav-btn" id="prevSection" onclick="prevSlide()">&#8249;</button>
    <span class="section-indicator" id="sectionIndicator">1 / 1</span>
    <button class="nav-btn" id="nextSection" onclick="nextSlide()">&#8250;</button>
  </div>
  <div class="header-right">
    <button class="nav-btn font-btn" onclick="changeFontSize(-1)" title="Decrease font size">A&#8722;</button>
    <button class="nav-btn font-btn" onclick="changeFontSize(1)" title="Increase font size">A+</button>
    <button class="nav-btn" id="darkToggle" onclick="toggleDark()" title="Toggle dark mode"><span id="darkIcon">&#9789;</span></button>
    <button class="nav-btn" title="Toggle sidebar" onclick="toggleSidebar()" style="font-size:14px">&#9776;</button>
  </div>
</header>

<div class="layout">
  <nav class="sidebar" id="sidebar">
    <div id="sidebarContent">
      <div class="loading"><div class="spinner"></div><div class="loading-text">Loading...</div></div>
    </div>
  </nav>

  <div class="main" id="mainArea">
    <div class="sections-container" id="sectionsContainer">
      <div class="welcome" id="welcomeScreen">
        <div class="welcome-icon">Go</div>
        <h1>Go Concurrency Mastery</h1>
        <p>A hands-on course to master concurrent programming in Go. Navigate sections horizontally with arrow keys or buttons.</p>
        <button class="welcome-btn" onclick="loadFirst()">Start Reading</button>
        <a class="welcome-btn resume-btn" id="resumeBtn" style="display:none" href="#">Continue Reading</a>
        <div class="welcome-hint">Use &#8592; &#8594; arrow keys to navigate sections</div>
      </div>
    </div>
    <div class="section-dots" id="sectionDots"></div>
  </div>
</div>

<script>
var __BASE_PATH__ = "..";
var __PAGE_ID__ = "chapter-01/PART1_SEQUENTIAL_BASELINE.md";
var __PAGE_CONTENT__ = "# Chapter 1, Part 1: The Sequential Baseline\n\n**Time to complete**: 20 minutes  \n**What you'll learn**: How to build a working counter and measure its performance\n\n---\n\n## Section 1.1: The Problem Statement\n\n### What We're Building\n\nA **URL hit counter** that:\n- Tracks how many times each URL has been accessed\n- Stores the counts in memory\n- Can tell you the current count for any URL\n\nThink of it like a simple in-memory database:\n```\nURL                          Count\nhttps://example.com/home  ‚Üí  1,523\nhttps://example.com/about ‚Üí  842\nhttps://example.com/blog  ‚Üí  5,721\n```\n\n### The API We Need\n\n```go\ntype URLCounter struct {\n    // We'll design this together\n}\n\n// RecordHit increments the count for a URL\nfunc (uc *URLCounter) RecordHit(url string) {\n    // To implement\n}\n\n// GetCount returns how many times a URL was hit\nfunc (uc *URLCounter) GetCount(url string) int {\n    // To implement\n}\n```\n\n### Success Criteria\n\nOur counter must:\n1. ‚úÖ Start at 0 for new URLs\n2. ‚úÖ Increment by 1 each time we record a hit\n3. ‚úÖ Return the correct count when asked\n4. ‚úÖ Never lose a count\n\nFor now, we'll ignore speed. We just want **correctness**.\n\n---\n\n## Section 1.2: Sequential Implementation\n\n### Choosing the Data Structure\n\nWe need to store: URL ‚Üí Count\n\nIn Go, the perfect data structure for this is a **map**:\n\n```go\ncounts := make(map[string]int)\ncounts[\"https://example.com\"] = 42\n```\n\nMaps give us O(1) lookup and update. Perfect!\n\n### The Complete Sequential Implementation\n\nLet's build it step by step:\n\n```go\n// File: sequential/counter.go\npackage main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\n// URLCounter tracks hits for each URL\ntype URLCounter struct {\n    counts map[string]int\n}\n\n// NewURLCounter creates a new counter\nfunc NewURLCounter() *URLCounter {\n    return \u0026URLCounter{\n        counts: make(map[string]int),\n    }\n}\n\n// RecordHit increments the counter for a URL\nfunc (uc *URLCounter) RecordHit(url string) {\n    uc.counts[url]++\n}\n\n// GetCount returns the hit count for a URL\nfunc (uc *URLCounter) GetCount(url string) int {\n    return uc.counts[url]\n}\n\nfunc main() {\n    counter := NewURLCounter()\n    \n    // Simulate 10,000 hits to the same URL\n    start := time.Now()\n    for i := 0; i \u003c 10000; i++ {\n        counter.RecordHit(\"https://example.com\")\n    }\n    elapsed := time.Since(start)\n    \n    fmt.Printf(\"Final count: %d\\n\", counter.GetCount(\"https://example.com\"))\n    fmt.Printf(\"Time taken: %v\\n\", elapsed)\n    fmt.Printf(\"‚úÖ Sequential version works perfectly!\\n\")\n}\n```\n\n### Line-by-Line Explanation\n\nLet's break down every part:\n\n#### The Struct\n\n```go\ntype URLCounter struct {\n    counts map[string]int\n}\n```\n\n**What this does:**\n- Creates a new type called `URLCounter`\n- Has one field: `counts`\n- `counts` is a map from strings (URLs) to ints (hit counts)\n\n**Why a map?**\n- We don't know all URLs ahead of time\n- Need fast lookups by URL\n- Maps automatically handle unknown keys (return 0)\n\n#### The Constructor\n\n```go\nfunc NewURLCounter() *URLCounter {\n    return \u0026URLCounter{\n        counts: make(map[string]int),\n    }\n}\n```\n\n**What this does:**\n- Creates a new `URLCounter` instance\n- Initializes the map with `make()`\n- Returns a pointer to the counter\n\n**Why initialize the map?**\n- In Go, an uninitialized map is `nil`\n- You can't add to a `nil` map ‚Üí runtime panic!\n- `make()` creates an empty, ready-to-use map\n\n**Try it yourself:**\n```go\n// This will PANIC!\nvar bad map[string]int\nbad[\"key\"] = 1  // panic: assignment to entry in nil map\n\n// This works:\ngood := make(map[string]int)\ngood[\"key\"] = 1  // ‚úÖ All good\n```\n\n#### Recording a Hit\n\n```go\nfunc (uc *URLCounter) RecordHit(url string) {\n    uc.counts[url]++\n}\n```\n\n**What this does:**\n- Takes a URL as input\n- Increments the count for that URL\n\n**How `++` works with maps:**\n```go\n// If URL not in map, Go returns 0\n// So this: uc.counts[url]++\n// Is really: uc.counts[url] = uc.counts[url] + 1\n\n// First hit: 0 + 1 = 1\n// Second hit: 1 + 1 = 2\n// Third hit: 2 + 1 = 3\n```\n\n**Try it yourself:**\n```go\nm := make(map[string]int)\nfmt.Println(m[\"unknown\"])  // Prints: 0\nm[\"unknown\"]++\nfmt.Println(m[\"unknown\"])  // Prints: 1\n```\n\n#### Getting the Count\n\n```go\nfunc (uc *URLCounter) GetCount(url string) int {\n    return uc.counts[url]\n}\n```\n\n**What this does:**\n- Takes a URL as input\n- Returns the count for that URL\n- Returns 0 if URL never seen before\n\n**Why return 0 for unknown URLs?**\n- Maps in Go have a clever default: accessing a missing key returns the zero value\n- For `int`, zero value is `0`\n- This is exactly what we want!\n\n#### The Main Function\n\n```go\nfunc main() {\n    counter := NewURLCounter()\n```\n\nCreates our counter.\n\n```go\n    start := time.Now()\n```\n\nRecords the current time so we can measure how long it takes.\n\n```go\n    for i := 0; i \u003c 10000; i++ {\n        counter.RecordHit(\"https://example.com\")\n    }\n```\n\nSimulates 10,000 hits to the same URL.\n\nIn a real server, each iteration would be a different HTTP request.\n\n```go\n    elapsed := time.Since(start)\n```\n\nCalculates how long the loop took.\n\n```go\n    fmt.Printf(\"Final count: %d\\n\", counter.GetCount(\"https://example.com\"))\n```\n\nPrints the final count. Should be exactly 10,000.\n\n---\n\n## Section 1.3: Running the Code\n\n### Create the File\n\n```bash\nmkdir sequential\ncd sequential\n```\n\nCreate `counter.go` and paste the code above.\n\n### Run It\n\n```bash\ngo run counter.go\n```\n\n### Expected Output\n\n```\nFinal count: 10000\nTime taken: 234¬µs\n‚úÖ Sequential version works perfectly!\n```\n\n**Your time will vary** depending on your machine, but should be in the microseconds range.\n\n### Understanding the Output\n\n- **Final count: 10000** ‚Üê Correct! No lost updates\n- **Time taken: 234¬µs** ‚Üê Pretty fast for 10,000 operations\n- **‚úÖ Works perfectly** ‚Üê No concurrency issues (yet!)\n\n### üèãÔ∏è Exercise 1.1: Run It Yourself\n\n1. Create the file\n2. Run it\n3. Run it again\n4. Run it 5 times\n\n**Question**: Does the count ever change?  \n**Answer**: No! It's always 10,000. This is **deterministic** behavior.\n\n### üèãÔ∏è Exercise 1.2: Try Different Numbers\n\nModify the code to do 100,000 hits instead of 10,000:\n\n```go\nfor i := 0; i \u003c 100000; i++ {\n```\n\n**Question**: How much slower is it?  \n**Typical answer**: About 10x slower (makes sense - 10x more work)\n\n### üèãÔ∏è Exercise 1.3: Track Multiple URLs\n\nModify main() to track 3 different URLs:\n\n```go\ncounter.RecordHit(\"https://example.com/home\")\ncounter.RecordHit(\"https://example.com/about\")\ncounter.RecordHit(\"https://example.com/home\")  // home again!\n\nfmt.Printf(\"/home count: %d\\n\", counter.GetCount(\"https://example.com/home\"))\nfmt.Printf(\"/about count: %d\\n\", counter.GetCount(\"https://example.com/about\"))\n```\n\n**Expected output**:\n```\n/home count: 2\n/about count: 1\n```\n\nDid you get it right? ‚úÖ\n\n---\n\n## Section 1.4: Measuring Performance\n\n### How Fast Is This?\n\nLet's add better measurement:\n\n```go\nfunc main() {\n    counter := NewURLCounter()\n    \n    const numHits = 10000\n    \n    start := time.Now()\n    for i := 0; i \u003c numHits; i++ {\n        counter.RecordHit(\"https://example.com\")\n    }\n    elapsed := time.Since(start)\n    \n    nanosPerOp := float64(elapsed.Nanoseconds()) / float64(numHits)\n    \n    fmt.Printf(\"Final count: %d\\n\", counter.GetCount(\"https://example.com\"))\n    fmt.Printf(\"Total time: %v\\n\", elapsed)\n    fmt.Printf(\"Time per operation: %.2f ns\\n\", nanosPerOp)\n    fmt.Printf(\"Operations per second: %.0f\\n\", 1_000_000_000/nanosPerOp)\n}\n```\n\n### Sample Output\n\n```\nFinal count: 10000\nTotal time: 234¬µs\nTime per operation: 23.40 ns\nOperations per second: 42,735,043\n```\n\n**Translation**: We can do about **43 million hits per second** on a single CPU core.\n\n**Wait, that's amazing!** Why did we say this is slow?\n\n### The Catch: It's Single-Threaded\n\nThis code runs on **one CPU core**. No matter how fast your CPU is, you're using 1 core out of 8, 16, or more.\n\n**Your computer probably has multiple cores:**\n```bash\n# On Linux/Mac:\nnproc\n# On my laptop: 8\n\n# On Windows PowerShell:\n# (Get-WmiObject Win32_Processor).NumberOfCores\n```\n\nIf you have 8 cores but use 1, you're using **12.5% of your CPU!**\n\n### Why This is Too Slow for Production\n\nLet's say we get 100,000 requests per second:\n\n**Sequential processing:**\n- 1 request at a time\n- Each takes 23 ns\n- 100,000 requests = 100,000 √ó 23 ns = 2,300,000 ns = **2.3 milliseconds**\n\nThat sounds fast! But:\n- Requests are arriving constantly\n- We need to process old requests while new ones come in\n- We fall behind almost immediately\n\n**What we really need:**\n- Process multiple requests simultaneously\n- Use all CPU cores\n- Handle 100,000 concurrent requests\n\nThat's where **concurrency** comes in!\n\n---\n\n## Section 1.5: Understanding the Bottleneck\n\n### Why Can't We Go Faster (Sequentially)?\n\nLook at this code again:\n\n```go\nfor i := 0; i \u003c 10000; i++ {\n    counter.RecordHit(\"https://example.com\")\n}\n```\n\n**This is sequential** - each iteration waits for the previous one to finish:\n\n```\nHit 1  ‚Üí Wait ‚Üí Hit 2  ‚Üí Wait ‚Üí Hit 3  ‚Üí Wait ‚Üí ...\n```\n\n**We want parallel** - many iterations at once:\n\n```\nHit 1  ‚Üì\nHit 2  ‚Üì  ‚Üê All happening simultaneously!\nHit 3  ‚Üì\nHit 4  ‚Üì\n...\n```\n\n### Visualizing the Difference\n\n**Sequential (Current):**\n```\nCore 1: [‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà] (working)\nCore 2: [                            ] (idle)\nCore 3: [                            ] (idle)\nCore 4: [                            ] (idle)\nCPU usage: 25% on 4-core machine\n```\n\n**Parallel (What We Want):**\n```\nCore 1: [‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà] (working)\nCore 2: [‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà] (working)\nCore 3: [‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà] (working)\nCore 4: [‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà] (working)\nCPU usage: 100%\nTime: 4x faster!\n```\n\n---\n\n## Section 1.6: Stop and Think ü§î\n\nBefore moving on, make sure you understand:\n\n### ‚ùì Quiz 1.1\n\n**Question**: Why does `RecordHit` not need to check if the URL exists in the map?\n\n\u003cdetails\u003e\n\u003csummary\u003eClick to see answer\u003c/summary\u003e\n\n**Answer**: Go maps return the zero value (0 for int) when accessing a non-existent key. So `counts[url]++` works even for new URLs:\n- First access: `0 + 1 = 1`\n- Second access: `1 + 1 = 2`\n- etc.\n\u003c/details\u003e\n\n### ‚ùì Quiz 1.2\n\n**Question**: What would happen if we removed `make(map[string]int)` from NewURLCounter?\n\n\u003cdetails\u003e\n\u003csummary\u003eClick to see answer\u003c/summary\u003e\n\n**Answer**: The program would panic with \"assignment to entry in nil map\" when RecordHit tries to update the map.\n\n```go\n// BAD: Map is nil\ntype URLCounter struct {\n    counts map[string]int  // This is nil!\n}\n\ncounter := \u0026URLCounter{}\ncounter.RecordHit(\"url\")  // PANIC!\n```\n\u003c/details\u003e\n\n### ‚ùì Quiz 1.3\n\n**Question**: Our sequential version does about 43 million operations per second. If we have 8 cores and make it perfectly parallel, how many operations per second could we theoretically do?\n\n\u003cdetails\u003e\n\u003csummary\u003eClick to see answer\u003c/summary\u003e\n\n**Answer**: 43 million √ó 8 cores = **344 million operations per second**\n\nIn reality, we won't get perfect 8x speedup due to:\n- Coordination overhead\n- Shared memory contention\n- Cache coherence costs\n\nBut we should get 5-7x speedup easily!\n\u003c/details\u003e\n\n---\n\n## Section 1.7: What's Next?\n\nYou now have:\n- ‚úÖ A working sequential counter\n- ‚úÖ Understanding of maps and basic Go patterns\n- ‚úÖ Baseline performance measurements\n- ‚úÖ Understanding of the bottleneck\n\n**Next**, we'll make it concurrent and watch it break spectacularly! üî•\n\nThis is where the fun (and learning) really begins!\n\n---\n\n## üèãÔ∏è Final Exercises for Part 1\n\nBefore moving on, complete these to cement your understanding:\n\n### Exercise 1.4: Add a Reset Method\n\nAdd a method to reset all counts to zero:\n\n```go\nfunc (uc *URLCounter) Reset() {\n    // Implement this\n}\n```\n\n**Hint**: You need to create a new map.\n\n\u003cdetails\u003e\n\u003csummary\u003eSolution\u003c/summary\u003e\n\n```go\nfunc (uc *URLCounter) Reset() {\n    uc.counts = make(map[string]int)\n}\n```\n\u003c/details\u003e\n\n### Exercise 1.5: Add a Total Method\n\nAdd a method that returns the total number of hits across all URLs:\n\n```go\nfunc (uc *URLCounter) Total() int {\n    // Implement this\n}\n```\n\n**Hint**: Range over the map.\n\n\u003cdetails\u003e\n\u003csummary\u003eSolution\u003c/summary\u003e\n\n```go\nfunc (uc *URLCounter) Total() int {\n    total := 0\n    for _, count := range uc.counts {\n        total += count\n    }\n    return total\n}\n```\n\u003c/details\u003e\n\n### Exercise 1.6: Track Response Times\n\nModify RecordHit to also track average response time:\n\n```go\ntype URLCounter struct {\n    counts map[string]int\n    avgResponseTime map[string]float64\n}\n\nfunc (uc *URLCounter) RecordHitWithTime(url string, responseTime float64) {\n    // Record hit AND update running average\n}\n```\n\nThis is harder! Try it yourself first.\n\n---\n\n## Summary\n\n**What you learned:**\n- How to build a URL counter with maps\n- How to measure performance\n- Why sequential processing has limits\n- The difference between using 1 core vs all cores\n\n**Key takeaway**: Sequential code is simple and correct, but can't use all your CPU cores.\n\n**Next**: We'll make it concurrent and discover race conditions! ‚Üí\n\n[Continue to Part 2: Breaking It - The Naive Concurrent Version](./PART2_NAIVE_CONCURRENT.md)\n";
var __STRUCTURE__ = {"title":"Go Concurrency Mastery","overview":[{"id":"COMPLETE_COURSE_CURRICULUM","title":"Go Concurrency Mastery: Complete Course Curriculum","filename":"COMPLETE_COURSE_CURRICULUM.md"}],"chapters":[{"id":"chapter-01","title":"Chapter 01: The Race Condition Crisis","dir":"chapter-01","parts":[{"id":"PART0_INTRODUCTION","title":"Chapter 1, Part 0: Introduction and Setup","filename":"PART0_INTRODUCTION.md"},{"id":"PART1_SEQUENTIAL_BASELINE","title":"Chapter 1, Part 1: The Sequential Baseline","filename":"PART1_SEQUENTIAL_BASELINE.md"},{"id":"PART3_RACE_CONDITIONS_DEEP_DIVE","title":"Chapter 1, Part 3: What IS a Race Condition? - Deep Dive","filename":"PART3_RACE_CONDITIONS_DEEP_DIVE.md"},{"id":"PART4_SOLUTION_CHANNELS","title":"Chapter 1, Part 4: Solution #1 - Channels","filename":"PART4_SOLUTION_CHANNELS.md"},{"id":"PART4-1CHANNELS_PRACTICE","title":"Channels Practice","filename":"PART4-1CHANNELS_PRACTICE.md"}]}]};
</script>
<script src="../app.js"></script>
</body>
</html>