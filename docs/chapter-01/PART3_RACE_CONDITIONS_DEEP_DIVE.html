<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Chapter 1, Part 3: What IS a Race Condition? - Deep Dive - Go Concurrency Course</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Source+Serif+4:opsz,wght@8..60,400;8..60,500;8..60,600;8..60,700&family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css" class="hljs-theme" data-theme="light">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css" class="hljs-theme" data-theme="dark" disabled>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/go.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/bash.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/marked/12.0.0/marked.min.js"></script>
<link rel="stylesheet" href="../style.css">
</head>
<body>

<header class="header">
  <button class="menu-toggle" onclick="toggleMobile()">&#9776;</button>
  <div class="header-brand">
    <div class="header-logo">Go</div>
    <span class="header-title">Go Concurrency</span>
    <div class="header-sep"></div>
    <span class="header-part-title" id="headerPart">Select a section to begin</span>
  </div>
  <div class="section-nav" id="sectionNav" style="display:none">
    <button class="nav-btn" id="prevSection" onclick="prevSlide()">&#8249;</button>
    <span class="section-indicator" id="sectionIndicator">1 / 1</span>
    <button class="nav-btn" id="nextSection" onclick="nextSlide()">&#8250;</button>
  </div>
  <div class="header-right">
    <button class="nav-btn font-btn" onclick="changeFontSize(-1)" title="Decrease font size">A&#8722;</button>
    <button class="nav-btn font-btn" onclick="changeFontSize(1)" title="Increase font size">A+</button>
    <button class="nav-btn" id="darkToggle" onclick="toggleDark()" title="Toggle dark mode"><span id="darkIcon">&#9789;</span></button>
    <button class="nav-btn" title="Toggle sidebar" onclick="toggleSidebar()" style="font-size:14px">&#9776;</button>
  </div>
</header>

<div class="layout">
  <nav class="sidebar" id="sidebar">
    <div id="sidebarContent">
      <div class="loading"><div class="spinner"></div><div class="loading-text">Loading...</div></div>
    </div>
  </nav>

  <div class="main" id="mainArea">
    <div class="sections-container" id="sectionsContainer">
      <div class="welcome" id="welcomeScreen">
        <div class="welcome-icon">Go</div>
        <h1>Go Concurrency Mastery</h1>
        <p>A hands-on course to master concurrent programming in Go. Navigate sections horizontally with arrow keys or buttons.</p>
        <button class="welcome-btn" onclick="loadFirst()">Start Reading</button>
        <a class="welcome-btn resume-btn" id="resumeBtn" style="display:none" href="#">Continue Reading</a>
        <div class="welcome-hint">Use &#8592; &#8594; arrow keys to navigate sections</div>
      </div>
    </div>
    <div class="section-dots" id="sectionDots"></div>
  </div>
</div>

<script>
var __BASE_PATH__ = "..";
var __PAGE_ID__ = "chapter-01/PART3_RACE_CONDITIONS_DEEP_DIVE.md";
var __PAGE_CONTENT__ = "# Chapter 1, Part 3: What IS a Race Condition? - Deep Dive\n\n**Time to complete**: 60 minutes  \n**What you'll learn**: The deep \"why\" behind race conditions - from CPU to memory to Go\n\n---\n\n## Section 3.1: Understanding Operations (Read-Modify-Write)\n\n### Where We Are\n\nIn Part 2, you saw this:\n```go\ncounter++  // Looks simple!\n```\n\nRun 10 times, got 10 different results. The race detector said: \"DATA RACE at this line!\"\n\n**Today's question**: WHY does one tiny `++` cause so much chaos?\n\n### The Big Reveal: `++` is NOT One Thing!\n\nWhen you write:\n```go\ncounter++\n```\n\nYou think: \"Add 1 to counter. Done!\"\n\n**But the CPU sees**:\n```go\n// Step 1: READ\ntemp = counter       // \"What's the current value?\"\n\n// Step 2: ADD  \ntemp = temp + 1      // \"Add 1 to it\"\n\n// Step 3: WRITE\ncounter = temp       // \"Store it back\"\n```\n\n**THREE separate operations!**\n\n### Let's Prove It\n\n**Create file**: `three_steps.go`\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    counter := 0\n    \n    // What you write\n    counter++\n    \n    // What really happens (shown explicitly)\n    counter_explicit := 0\n    temp := counter_explicit     // Step 1: READ\n    temp = temp + 1              // Step 2: ADD\n    counter_explicit = temp      // Step 3: WRITE\n    \n    fmt.Println(\"counter:\", counter)\n    fmt.Println(\"counter_explicit:\", counter_explicit)\n    // Both print 1\n}\n```\n\n**Run it**:\n```bash\ngo run three_steps.go\n```\n\n```\ncounter: 1\ncounter_explicit: 1\n```\n\nSee? **Exact same result!** Because they're doing the exact same three steps.\n\n### Why This Matters for Concurrency\n\n**Sequential (one goroutine)**:\n```\nStep 1: READ counter (gets 0)\nStep 2: ADD 1 (0 + 1 = 1)\nStep 3: WRITE counter (stores 1)\nResult: ‚úÖ counter = 1\n```\n\nNo problem! Steps execute in order.\n\n**Concurrent (two goroutines)**:\n\n```\nTime    Goroutine A              Goroutine B              counter\n----    -----------              -----------              -------\nt0                                                        0\nt1      Step 1: READ (gets 0)                             0\nt2                               Step 1: READ (gets 0)    0\nt3      Step 2: ADD (0+1=1)                               0\nt4                               Step 2: ADD (0+1=1)      0\nt5      Step 3: WRITE (stores 1)                     1\nt6                               Step 3: WRITE (stores 1) 1 ‚Üê WRONG!\n```\n\n**Result**: counter = 1, but should be 2!\n\n**What happened?**\n- Both READ before either WROTE\n- Both read 0\n- Both calculated 1\n- Both wrote 1\n- One increment **lost**!\n\n### The Word for This: \"Atomicity\"\n\n**Atomic** comes from Greek \"atomos\" = \"cannot be divided\"\n\n**Atomic operation** = Can't be split into smaller pieces\n\n```go\ncounter++  // NOT atomic (three pieces!)\n```\n\nIf `counter++` were truly atomic, the whole thing would execute as one indivisible unit. No goroutine could see it half-done.\n\nBut it's NOT atomic. It's three operations. Other goroutines can jump in between!\n\n### üèãÔ∏è Exercise 3.1: Trace the Execution\n\nGiven this code:\n```go\nbalance := 100\n\n// Goroutine A\ntemp1 := balance    // Step A1: READ\ntemp1 = temp1 - 50  // Step A2: SUBTRACT\nbalance = temp1     // Step A3: WRITE\n\n// Goroutine B  \ntemp2 := balance    // Step B1: READ\ntemp2 = temp2 - 30  // Step B2: SUBTRACT\nbalance = temp2     // Step B3: WRITE\n```\n\nFill in this timeline showing one possible interleaving:\n\n```\nTime    Goroutine A      Goroutine B      balance\nt0                                        100\nt1      A1: READ 100                      100\nt2                       B1: READ ___     100\nt3      A2: CALC ___                      100\nt4                       B2: CALC ___     100\nt5      A3: WRITE ___                     ___\nt6                       B3: WRITE ___    ___\n```\n\n**Final balance should be?** ___  \n**Actual final balance?** ___\n\n\u003cdetails\u003e\n\u003csummary\u003eSolution\u003c/summary\u003e\n\n```\nTime    Goroutine A      Goroutine B      balance\nt0                                        100\nt1      A1: READ 100                      100\nt2                       B1: READ 100     100\nt3      A2: CALC 50                       100\nt4                       B2: CALC 70      100\nt5      A3: WRITE 50                      50\nt6                       B3: WRITE 70     70\n```\n\n**Should be**: $20 (100 - 50 - 30)  \n**Actually is**: $70 (the $50 withdrawal was lost!)\n\n\u003c/details\u003e\n\n### Why Does the CPU Do This?\n\n**Why not make everything atomic?**\n\nBecause it would be **impossibly slow**!\n\nThe CPU works with **registers** (super-fast temporary storage):\n1. Registers are 1000x faster than RAM\n2. CPU must load data into registers to work with it\n3. Do math in registers\n4. Store back to RAM\n\n**This is fundamental to how computers work!**\n\nMaking every operation atomic would mean:\n- No other CPU could touch that memory during operation\n- Everything slows down massively\n- Can't use multiple cores effectively\n\nSo instead, we get fast operations that aren't atomic, and we must **synchronize manually**.\n\n### ‚ùì Quiz 3.1: Understanding Read-Modify-Write\n\n**Question 1**: How many actual CPU operations is `x = x + 1`?\n\nA) 1  \nB) 2  \nC) 3  \nD) 4  \n\n\u003cdetails\u003e\n\u003csummary\u003eAnswer\u003c/summary\u003e\n\n**C) 3**: READ x, ADD 1, WRITE x\n\nEven though it looks like one operation, the CPU must read, modify, and write.\n\n\u003c/details\u003e\n\n**Question 2**: If two goroutines execute `counter++` on counter = 5, what are the possible final values?\n\nA) Only 7  \nB) Only 6  \nC) 6 or 7  \nD) 5, 6, or 7  \n\n\u003cdetails\u003e\n\u003csummary\u003eAnswer\u003c/summary\u003e\n\n**C) 6 or 7**\n\n- If they don't overlap: 5 ‚Üí 6 ‚Üí 7 ‚úÖ\n- If they both read 5: both write 6 (one lost) ‚Üí 6 ‚úÖ\n- 5 is impossible (at least one increment happens)\n- 7 is possible (perfect ordering)\n- 6 is possible (overlapping reads)\n\n\u003c/details\u003e\n\n**Question 3**: Which of these is atomic?\n\nA) `counter++`  \nB) `counter = 5`  \nC) `if counter \u003e 0 { counter-- }`  \nD) None of the above  \n\n\u003cdetails\u003e\n\u003csummary\u003eAnswer\u003c/summary\u003e\n\n**D) None of the above**\n\nSurprise! Even `counter = 5` is not guaranteed atomic on all architectures for all types. A simple assignment can involve multiple operations if the value is larger than the CPU's word size.\n\nOption C is definitely not atomic (read, compare, then write).\n\n**Only operations explicitly documented as atomic are atomic!** (We'll learn about `sync/atomic` package later)\n\n\u003c/details\u003e\n\n### Different Operations, Same Problem\n\n**It's not just `++`!**\n\nAll of these have the read-modify-write problem:\n\n```go\ncounter++           // READ, ADD, WRITE\ncounter--           // READ, SUBTRACT, WRITE\ncounter += 5        // READ, ADD 5, WRITE\ncounter *= 2        // READ, MULTIPLY, WRITE\nbalance = balance - amount  // READ, SUBTRACT, WRITE\n\n// Even this!\nif balance \u003e amount {\n    balance -= amount    // READ (in 'if'), READ again, SUBTRACT, WRITE\n}\n```\n\n**The pattern**: If you READ a value, do something with it, then WRITE it back ‚Üí **RACE DANGER!**\n\n---\n\n## Section 3.2: The Lost Update Problem (With Timeline)\n\n### The Classic Problem\n\nThe \"Lost Update\" is the formal name for what we've been seeing.\n\n**Definition**: When two operations both read the same value, modify it, and write back, one update is lost.\n\n### Banking Example\n\nLet's make it real with a bank account:\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\nvar balance = 1000  // Shared bank balance\n\nfunc withdraw(amount int, name string) {\n    // Step 1: Check if enough money\n    if balance \u003e= amount {\n        // Simulate some processing time\n        time.Sleep(10 * time.Millisecond)\n        \n        // Step 2: Withdraw\n        balance = balance - amount\n        fmt.Printf(\"%s withdrew $%d, balance now $%d\\n\", name, amount, balance)\n    } else {\n        fmt.Printf(\"%s: insufficient funds\\n\", name)\n    }\n}\n\nfunc main() {\n    // Two people try to withdraw at the same time\n    go withdraw(600, \"Alice\")\n    go withdraw(500, \"Bob\")\n    \n    time.Sleep(1 * time.Second)\n    fmt.Printf(\"Final balance: $%d\\n\", balance)\n}\n```\n\n**Run this several times:**\n\n```bash\ngo run bank.go\n```\n\n**Possible outputs:**\n\n**Run 1**:\n```\nAlice withdrew $600, balance now $400\nBob withdrew $500, balance now $500\nFinal balance: $500\n```\n**Wait, what?!** Started with $1000, withdrew $1100 total, but balance shows $500?\n\n**Run 2**:\n```\nBob withdrew $500, balance now $500\nAlice withdrew $600, balance now $400\nFinal balance: $400\n```\n\nDifferent result!\n\n**Run 3**:\n```\nAlice withdrew $600, balance now $400\nBob: insufficient funds\nFinal balance: $400\n```\n\nThis one is correct!\n\n### What's Happening: The Timeline\n\n**Bad Interleaving** (money appears from nowhere):\n\n```\nTime    Alice                     Bob                    balance\n----    -----                     ---                    -------\nt0                                                        1000\nt1      Check: 1000 \u003e= 600? ‚úÖ                            1000\nt2                               Check: 1000 \u003e= 500? ‚úÖ   1000\nt3      Sleep 10ms...                                     1000\nt4                               Sleep 10ms...            1000\nt5      balance = 1000-600=400                            400\nt6                               balance = 1000-500=500   500 ‚Üê WRONG!\n```\n\n**Both**:\n- Read balance = 1000\n- Passed the check\n- Calculated their new balance\n- Wrote their result\n\nBob's write **overwrites** Alice's! Alice's withdrawal is **lost**!\n\n**Good Interleaving** (correct behavior):\n\n```\nTime    Alice                   Bob                    balance\n----    -----                   ---                    -------\nt0                                                     1000\nt1      Check: 1000 \u003e= 600? ‚úÖ                         1000\nt2      Sleep 10ms...                                  1000\nt3      balance = 1000-600=400                         400\nt4                              Check: 400 \u003e= 500? ‚ùå  400\nt5                              \"insufficient funds\"   400\n```\n\nAlice completes before Bob checks. Bob sees the updated balance. Correct!\n\n### This Is Called \"Check-Then-Act\"\n\n**The pattern**:\n```go\nif condition {\n    // \"Then-Act\" happens here\n    doSomething()\n}\n```\n\n**The race**: Between checking the condition and acting on it, another goroutine can change things!\n\n**More examples**:\n\n```go\n// Check if file exists, then delete\nif fileExists(path) {\n    deleteFile(path)  // ‚Üê Another goroutine might have deleted it!\n}\n\n// Check inventory, then decrement\nif inventory \u003e 0 {\n    inventory--  // ‚Üê Might now be negative!\n}\n\n// Check map, then write\nif _, exists := m[key]; !exists {\n    m[key] = value  // ‚Üê Key might exist now!\n}\n```\n\n### üèãÔ∏è Exercise 3.2: Count the Possible Outcomes\n\nGiven:\n```go\nvar balance = 100\n\n// Goroutine A: Withdraw $60\nif balance \u003e= 60 {\n    balance = balance - 60\n}\n\n// Goroutine B: Withdraw $80\nif balance \u003e= 80 {\n    balance = balance - 80\n}\n```\n\n**List all possible final balances and explain how each occurs.**\n\n\u003cdetails\u003e\n\u003csummary\u003eSolution\u003c/summary\u003e\n\n**Possible outcomes:**\n\n**1. balance = $100** (neither withdraws)\n- B checks first: 100 \u003c 80? No\n- A checks: 100 \u003c 60? No\n- (This is actually impossible since 100 \u003e= 60 and 100 \u003e= 80)\n\nActually, let me recalculate:\n\n**1. balance = $40** (only A withdraws)\n- A checks: 100 \u003e= 60? Yes\n- A withdraws: balance = 40\n- B checks: 40 \u003e= 80? No\n- Final: $40\n\n**2. balance = $20** (only B withdraws)\n- B checks: 100 \u003e= 80? Yes\n- B withdraws: balance = 20\n- A checks: 20 \u003e= 60? No\n- Final: $20\n\n**3. balance = $-40** (both withdraw - OVERDRAFT!)\n- A checks: 100 \u003e= 60? Yes\n- B checks: 100 \u003e= 80? Yes (before A writes)\n- A writes: 100 - 60 = 40\n- B writes: 100 - 80 = 20\n- Wait, B would write based on reading 100!\n- So: B writes: 100 - 80 = 20\n- Final: $20 (A's withdrawal lost)\n\nActually the most dangerous:\n- A checks: 100 \u003e= 60? Yes\n- B checks: 100 \u003e= 80? Yes\n- A writes: 40\n- B checks again based on old read, writes: 20\n- OR if B read 40: B writes: -40 (OVERDRAFT!)\n\nThe race makes multiple outcomes possible, including impossible ones like negative balances!\n\n\u003c/details\u003e\n\n### Why This Is SO Dangerous\n\n**In production**:\n- Thousands of requests per second\n- Race happens 0.1% of the time\n- That's still hundreds of times per day!\n- Money appears/disappears\n- Inventory goes negative\n- Tickets get double-booked\n\n**Real example**: E-commerce site had 10 of Product X. Race condition allowed 15 people to checkout. Site had to:\n- Honor all 15 orders (customer service nightmare)\n- Or cancel 5 orders (angry customers)\n- Loss: Either money or reputation\n\n### ‚ùì Quiz 3.2: Understanding Lost Updates\n\n**Question 1**: Why doesn't the lost update happen every time?\n\n\u003cdetails\u003e\n\u003csummary\u003eAnswer\u003c/summary\u003e\n\n**Timing!** The race only happens when goroutines execute at the exact same time. If one completes before the other starts, no race. The probability depends on:\n- How long each operation takes\n- How many goroutines are running\n- CPU scheduling\n- System load\n\nThat's why races are \"Heisenbugs\" - they appear and disappear based on timing.\n\n\u003c/details\u003e\n\n**Question 2**: If we add `time.Sleep(1 * time.Second)` between the check and the write, does that fix the race?\n\n\u003cdetails\u003e\n\u003csummary\u003eAnswer\u003c/summary\u003e\n\n**No! It makes it WORSE!** \n\nThe sleep increases the window where another goroutine can interfere. You're more likely to have overlapping execution.\n\nSleep is never a fix for races - it's just a testing tool to make races more visible.\n\n\u003c/details\u003e\n\n---\n\n## Section 3.3: Memory and Caches (Beginner-Friendly)\n\n### The Memory You Don't See\n\nWhen you write:\n```go\ncounter = 42\n```\n\nYou think: \"I wrote 42 to memory. Everyone can see it now!\"\n\n**Reality**: Not so fast!\n\n### CPUs Have Caches\n\nModern CPUs don't work directly with main memory (RAM). They use **caches** - super-fast local copies.\n\n```\nCPU Core 1:  [L1 Cache] ‚Üê Ultra fast\n              ‚Üì\n             [L2 Cache] ‚Üê Very fast\n              ‚Üì\n             [L3 Cache] ‚Üê Fast (shared with other cores)\n              ‚Üì\n             [RAM]      ‚Üê Slow (shared by all cores)\n              ‚Üì\nCPU Core 2:  [L1 Cache] ‚Üê Has its own copy!\n```\n\n**Why caches?**\n- RAM is ~100-300 cycles away\n- L1 cache is ~4 cycles away\n- That's 75x faster!\n\nBut here's the problem: **Each CPU core has its own L1 cache**. They can have **different values** for the same memory location!\n\n### The Google Docs Analogy\n\nImagine you and your friend editing a document:\n\n**No caching** (slow but always in sync):\n```\nYou: Type \"Hello\"\n     ‚Üì Save to cloud ‚Üì\nFriend: Sees \"Hello\" immediately\n```\n\n**With caching** (fast but can be out of sync):\n```\nYou: Type \"Hello\" ‚Üí Saved to local draft\nFriend's screen: Still shows \"\" (old version)\n     ‚Üì Eventually syncs ‚Üì\nFriend: Now sees \"Hello\"\n```\n\n**That delay is the problem!**\n\nYour write to \"local draft\" (L1 cache) doesn't instantly appear in your friend's view (their L1 cache).\n\n### Real Example with Code\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\nvar ready = false\nvar message = \"\"\n\nfunc writer() {\n    message = \"Hello, world!\"  // Write 1\n    ready = true               // Write 2\n}\n\nfunc reader() {\n    for !ready {  // Wait for ready\n        // Spin\n    }\n    fmt.Println(message)\n}\n\nfunc main() {\n    go reader()\n    go writer()\n    time.Sleep(1 * time.Second)\n}\n```\n\n**You expect**: Prints \"Hello, world!\"\n\n**Might actually print**: \"\" (empty string!)\n\n**Why?**\n\n```\nCore 1 (writer):              Core 2 (reader):\nmessage = \"Hello!\" in L1      ready = false in L1\nready = true in L1            Spinning, checking ready...\n                              ready still false in cache!\n                              ‚Üê Never sees the update!\n```\n\nOr even worse:\n\n```\nCore 2 might see:\n- ready = true (cache updated)\n- message = \"\" (cache still stale)\n\nPrints empty string!\n```\n\n**The writes don't happen in order from Core 2's perspective!**\n\n### Cache Coherence (MESI Protocol)\n\nCPUs have a protocol to keep caches consistent, called **MESI**:\n\n- **M**odified: I changed this; others' copies are invalid\n- **E**xclusive: Only I have this; it's up to date\n- **S**hared: Multiple cores have this; all match memory\n- **I**nvalid: My copy is stale; need to refetch\n\nBut this protocol **takes time**! Invalidation isn't instant.\n\n### When Do Writes Become Visible?\n\n**Without synchronization**: Undefined! Could be:\n- Immediately\n- A few nanoseconds later\n- A few microseconds later\n- Never (CPU reordered and eliminated it)\n\n**With synchronization** (mutex, channel, atomic): The synchronization **forces** cache updates.\n\nWhen you:\n```go\nmu.Lock()\ncounter++\nmu.Unlock()\n```\n\nThe `Unlock()` tells the CPU: \"Make sure my writes are visible to everyone!\"\n\n### üèãÔ∏è Exercise 3.3: Predict the Behavior\n\n```go\nvar x = 0\nvar y = 0\n\n// Goroutine 1\nx = 1\ny = 1\n\n// Goroutine 2\nif y == 1 {\n    fmt.Println(x)  // What might this print?\n}\n```\n\n**Without synchronization, what are possible outputs?**\n\nA) Always prints 1  \nB) Always prints 0  \nC) Might print 0 or 1  \nD) Might not print at all  \n\n\u003cdetails\u003e\n\u003csummary\u003eAnswer\u003c/summary\u003e\n\n**C) Might print 0 or 1** (and D is also possible!)\n\n**Scenario 1**: Goroutine 2 sees y=1, and x=1 ‚Üí Prints 1 ‚úÖ\n\n**Scenario 2**: Goroutine 2 sees y=1 (cache updated), but x still cached as 0 ‚Üí Prints 0! ‚úÖ\n\n**Scenario 3**: Goroutine 2 never sees y=1, doesn't print ‚úÖ\n\n**This is a classic memory visibility race!**\n\n\u003c/details\u003e\n\n### The Mental Model\n\nThink of each CPU core as having a **personal notebook** (cache).\n\nWhen you write `x = 5`:\n1. Write to your personal notebook (L1 cache)\n2. Eventually tell other cores: \"Hey, I updated x!\"\n3. They mark their copy as \"stale\"\n4. Next time they read x, they fetch the new value\n\n**The problem**: \"Eventually\" is not instant!\n\n### ‚ùì Quiz 3.3: Memory and Caches\n\n**Question 1**: If Goroutine A writes `counter = 10` on Core 1, when is Goroutine B on Core 2 guaranteed to see it?\n\nA) Immediately  \nB) After a few nanoseconds  \nC) Only when Goroutine B reads counter  \nD) Only when proper synchronization is used  \n\n\u003cdetails\u003e\n\u003csummary\u003eAnswer\u003c/summary\u003e\n\n**D) Only when proper synchronization is used**\n\nWithout synchronization (mutex, channel, atomic), there's NO guarantee about when or even if Goroutine B will see the write!\n\nThe compiler and CPU can reorder, cache, and optimize in ways that make the write invisible without synchronization.\n\n\u003c/details\u003e\n\n**Question 2**: True or False: RAM is one shared location that all cores see identically.\n\n\u003cdetails\u003e\n\u003csummary\u003eAnswer\u003c/summary\u003e\n\n**False!**\n\nWhile RAM is physically shared, each core works with **cached copies** in L1/L2/L3. Those caches can have different values! \n\nRAM is the \"source of truth\" but cores don't always read from RAM - they read from their cache.\n\n\u003c/details\u003e\n\n---\n\n## Section 3.4: The Three Conditions for a Race\n\n### The Formula for Disaster\n\nA data race occurs **ONLY** when ALL THREE conditions are true:\n\n1. **Multiple goroutines** access the same memory location\n2. **At least one access is a WRITE**\n3. **No synchronization** coordinates the accesses\n\n**Break ANY ONE condition** ‚Üí No race!\n\n### Condition 1: Multiple Goroutines\n\n```go\n// NO RACE: Only one goroutine\nfunc main() {\n    counter := 0\n    for i := 0; i \u003c 1000; i++ {\n        counter++  // Safe! No concurrency\n    }\n    fmt.Println(counter)  // Always 1000\n}\n```\n\n**No concurrency = No race**. Simple!\n\n### Condition 2: At Least One Write\n\n```go\n// NO RACE: Only reads\nconst MaxRetries = 5  // Never written after initialization\n\ngo func() {\n    for i := 0; i \u003c MaxRetries; i++ {  // Safe! Only reading\n        // ...\n    }\n}()\n\ngo func() {\n    for i := 0; i \u003c MaxRetries; i++ {  // Also safe!\n        // ...\n    }\n}()\n```\n\n**Multiple readers, no writers = No race**\n\n**Both reading the same data = Totally safe!**\n\n### Condition 3: No Synchronization\n\n```go\n// NO RACE: Proper synchronization\nvar mu sync.Mutex\nvar counter int\n\ngo func() {\n    mu.Lock()\n    counter++  // Protected!\n    mu.Unlock()\n}()\n\ngo func() {\n    mu.Lock()\n    counter++  // Also protected!\n    mu.Unlock()\n}()\n```\n\n**Synchronization coordinates access** ‚Üí No race!\n\n(We'll learn exactly how in Parts 4-6)\n\n### The Three-Condition Test\n\n**Use this for code review**:\n\nGiven any shared variable, ask:\n\n1. ‚úì Do multiple goroutines access it?\n2. ‚úì Does at least one goroutine write to it?\n3. ‚úì Is there NO mutex/channel/atomic protecting it?\n\n**All three YES?** ‚Üí DATA RACE! üî•\n\n**Any NO?** ‚Üí No race (at least not a data race)\n\n### üèãÔ∏è Exercise 3.4: Apply the Three-Condition Test\n\nFor each code snippet, identify if there's a race:\n\n**Example 1**:\n```go\nvar hits int\n\ngo func() {\n    hits++  // Goroutine A\n}()\n\ngo func() {\n    hits++  // Goroutine B\n}()\n```\n\n1. Multiple goroutines? ____\n2. At least one write? ____\n3. No synchronization? ____\n**Race?** ____\n\n\u003cdetails\u003e\n\u003csummary\u003eSolution\u003c/summary\u003e\n\n1. Multiple goroutines? **YES** (A and B)\n2. At least one write? **YES** (both write)\n3. No synchronization? **YES** (no mutex, channel, or atomic)\n\n**Race? YES** ‚úÖ\n\n\u003c/details\u003e\n\n**Example 2**:\n```go\nvar config = Config{Timeout: 5}\n\ngo func() {\n    fmt.Println(config.Timeout)  // Goroutine A\n}()\n\ngo func() {\n    fmt.Println(config.Timeout)  // Goroutine B\n}()\n```\n\n1. Multiple goroutines? ____\n2. At least one write? ____\n3. No synchronization? ____\n**Race?** ____\n\n\u003cdetails\u003e\n\u003csummary\u003eSolution\u003c/summary\u003e\n\n1. Multiple goroutines? **YES** (A and B)\n2. At least one write? **NO** (both only read!)\n3. No synchronization? **YES**\n\n**Race? NO** ‚úÖ (Condition 2 is not met)\n\nMultiple readers, no writers = Safe!\n\n\u003c/details\u003e\n\n**Example 3**:\n```go\nvar mu sync.Mutex\nvar balance int\n\ngo func() {\n    mu.Lock()\n    balance = 100  // Goroutine A\n    mu.Unlock()\n}()\n\ngo func() {\n    mu.Lock()\n    balance = 200  // Goroutine B\n    mu.Unlock()\n}()\n```\n\n1. Multiple goroutines? ____\n2. At least one write? ____\n3. No synchronization? ____\n**Race?** ____\n\n\u003cdetails\u003e\n\u003csummary\u003eSolution\u003c/summary\u003e\n\n1. Multiple goroutines? **YES**\n2. At least one write? **YES**\n3. No synchronization? **NO** (mutex protects it!)\n\n**Race? NO** ‚úÖ (Condition 3 is not met)\n\nThe mutex provides synchronization!\n\n\u003c/details\u003e\n\n**Example 4** (Tricky!):\n```go\nvar data = []int{1, 2, 3}\n\ngo func() {\n    fmt.Println(data[0])  // Goroutine A reads\n}()\n\ngo func() {\n    data = append(data, 4)  // Goroutine B writes\n}()\n```\n\n1. Multiple goroutines? ____\n2. At least one write? ____\n3. No synchronization? ____\n**Race?** ____\n\n\u003cdetails\u003e\n\u003csummary\u003eSolution\u003c/summary\u003e\n\n1. Multiple goroutines? **YES**\n2. At least one write? **YES** (B writes via append)\n3. No synchronization? **YES**\n\n**Race? YES** ‚úÖ\n\nEven though A only reads, B writes! That's a read-write race!\n\nPlus, `append` might change the slice header (pointer, length, capacity) while A reads it!\n\n\u003c/details\u003e\n\n### ‚ùì Quiz 3.4: The Three Conditions\n\n**Question 1**: Can two goroutines both READ the same variable without a race?\n\n\u003cdetails\u003e\n\u003csummary\u003eAnswer\u003c/summary\u003e\n\n**YES!**\n\nMultiple concurrent reads are safe. The three-condition test:\n1. Multiple goroutines? Yes\n2. At least one write? **NO**\n3. No synchronization? Yes\n\nSince condition 2 is NO, there's no race!\n\n\u003c/details\u003e\n\n**Question 2**: If I have ONE goroutine writing and many reading, is there a race?\n\n\u003cdetails\u003e\n\u003csummary\u003eAnswer\u003c/summary\u003e\n\n**YES! Absolutely a race!**\n\nOne write + multiple reads = read-write race\n\n1. Multiple goroutines? Yes\n2. At least one write? **YES**\n3. No synchronization? Yes (assuming no protection)\n\nAll three YES = RACE!\n\n\u003c/details\u003e\n\n---\n\n## Section 3.5: Types of Races\n\n### Type 1: Write-Write Races (Lost Updates)\n\n**Pattern**: Two goroutines both WRITE to the same location\n\n```go\nvar counter int\n\ngo func() { counter = 5 }()   // Write A\ngo func() { counter = 10 }()  // Write B\n```\n\n**Possible outcomes**:\n- counter = 5 (B runs first, A overwrites)\n- counter = 10 (A runs first, B overwrites)\n\n**One write always lost!**\n\n### Type 2: Read-Write Races (Stale Data)\n\n**Pattern**: One goroutine READS while another WRITES\n\n```go\nvar config = \"localhost:8080\"\n\ngo func() {\n    // Reader\n    conn := dial(config)  // Reads config\n}()\n\ngo func() {\n    // Writer\n    config = \"localhost:9090\"  // Writes config\n}()\n```\n\n**Possible outcomes**:\n- Reader sees \"localhost:8080\" (old value)\n- Reader sees \"localhost:9090\" (new value)\n- Reader sees partial write (CORRUPTION!) \n\n**The last one is the nightmare scenario!**\n\n### Type 3: NOT A RACE: Read-Read\n\n```go\nconst port = 8080\n\ngo func() { \n    fmt.Println(port)  // Read A\n}()\n\ngo func() {\n    fmt.Println(port)  // Read B\n}()\n```\n\n**This is SAFE!**\n\nBoth reading, no writing. No race!\n\n### Go-Specific Races\n\n**Map Races (Runtime Detection)**:\n\n```go\nm := make(map[string]int)\n\ngo func() { m[\"a\"] = 1 }()  // Write\ngo func() { _ = m[\"a\"] }()   // Read\n\n// Might result in: fatal error: concurrent map read and map write\n// Or might result in: silent corruption, wrong data, or random crash\n```\n\n**Why does Go sometimes panic?**\n\nGo includes **best-effort detection** of concurrent map access. When the runtime detects the race (which it often does, but not always), it crashes your program with a fatal error.\n\n**Why crash instead of just letting it race?**\n\nBecause silent data corruption is much worse than a loud crash! If Go didn't try to detect this:\n- Your map could get corrupted internally\n- You'd get wrong data with no warning\n- The bug would be nearly impossible to debug\n\n**The catch**: Detection is **not guaranteed**. The runtime checks a flag during map operations, but:\n- The check itself can be racy\n- Short-lived goroutines might not overlap\n- Some races slip through and cause silent corruption\n\n**The reliable way to find map races**: Use the race detector!\n```bash\ngo run -race your_program.go\n```\n\nThe `-race` flag instruments your code to catch ALL races, not just the ones the runtime happens to detect.\n\n**A more reliable example** (for demonstration):\n```go\nm := make(map[int]int)\n\n// Many concurrent operations increase detection probability\ngo func() {\n    for i := 0; i \u003c 10000; i++ {\n        m[i] = i\n    }\n}()\n\ngo func() {\n    for i := 0; i \u003c 10000; i++ {\n        _ = m[i]\n    }\n}()\n\ntime.Sleep(100 * time.Millisecond)\n// Usually panics: fatal error: concurrent map read and map write\n```\n\n**Key lesson**: Don't rely on the panic to catch bugs! Use:\n1. Proper synchronization (mutex, channels - we'll learn these soon!)\n2. The race detector (`-race` flag) during testing\n\n**The fix**: Use `sync.Mutex` or `sync.Map`\n\n**Interface Races (Memory Safety Violation)**:\n\nInterfaces are TWO words: type pointer + data pointer\n\n```go\nvar handler interface{}\n\ngo func() { handler = \u0026TypeA{} }()\ngo func() { handler = \u0026TypeB{} }()\n```\n\n**Danger**: Might end up with TypeA's pointer + TypeB's data = **MEMORY CORRUPTION!**\n\nThis can break Go's memory safety without using `unsafe`!\n\n**Slice Races (Bounds Corruption)**:\n\nSlices are THREE words: pointer + length + capacity\n\n```go\nvar data []int\n\ngo func() { data = []int{1, 2, 3} }()\ngo func() { data = []int{4, 5, 6, 7, 8} }()\n```\n\n**Danger**: Might see pointer from first write with length from second = **out of bounds panic or wrong data!**\n\n### The Loop Variable Trap (Classic Bug)\n\n```go\nfor i := 0; i \u003c 5; i++ {\n    go func() {\n        fmt.Println(i)  // BUG! Captures variable, not value\n    }()\n}\n// Might print: 5 5 5 5 5\n```\n\n**Why?** All goroutines share the **same** loop variable `i`. By the time they run, `i = 5`!\n\n**Fix 1**: Pass as parameter\n```go\nfor i := 0; i \u003c 5; i++ {\n    go func(n int) {\n        fmt.Println(n)  // ‚úÖ Each goroutine gets its own copy\n    }(i)\n}\n```\n\n**Fix 2**: Create local copy (Go 1.22+ doesn't need this anymore!)\n```go\nfor i := 0; i \u003c 5; i++ {\n    i := i  // Create new variable\n    go func() {\n        fmt.Println(i)  // ‚úÖ Captures local copy\n    }()\n}\n```\n\n### üèãÔ∏è Exercise 3.5: Classify the Races\n\nIdentify the type of race (or \"no race\"):\n\n**1.**\n```go\nvar x int\ngo func() { x = 1 }()\ngo func() { x = 2 }()\n```\n**Type**: ____________\n\n\u003cdetails\u003e\n\u003csummary\u003eAnswer\u003c/summary\u003e\n**Write-Write race** (both goroutines write to x)\n\u003c/details\u003e\n\n**2.**\n```go\nvar msg = \"hello\"\ngo func() { msg = \"world\" }()\ngo func() { fmt.Println(msg) }()\n```\n**Type**: ____________\n\n\u003cdetails\u003e\n\u003csummary\u003eAnswer\u003c/summary\u003e\n**Read-Write race** (one writes, one reads)\n\u003c/details\u003e\n\n**3.**\n```go\nconst MaxSize = 100\ngo func() { arr := make([]int, MaxSize) }()\ngo func() { arr := make([]int, MaxSize) }()\n```\n**Type**: ____________\n\n\u003cdetails\u003e\n\u003csummary\u003eAnswer\u003c/summary\u003e\n**No race** - Each goroutine has its own local `arr` variable. They don't share memory.\n\u003c/details\u003e\n\n**4.**\n```go\nm := make(map[int]int)\ngo func() { m[1] = 100 }()\ngo func() { m[2] = 200 }()\n```\n**Type**: ____________\n\n\u003cdetails\u003e\n\u003csummary\u003eAnswer\u003c/summary\u003e\n**Map race** (Write-Write on map internals)\n\nEven though they're writing to different keys, they're both modifying the map's internal structure. Go will panic: \"concurrent map writes\"\n\u003c/details\u003e\n\n---\n\n## Section 3.6: Practice Identifying Races (10 Examples)\n\n### Instructions\n\nFor each code example:\n1. Decide if there's a race\n2. If YES, identify which type\n3. Explain why\n4. Suggest a fix (we'll learn the details in Parts 4-6!)\n\n### Example 1\n\n```go\nvar count int\n\nfunc increment() {\n    count++\n}\n\nfunc main() {\n    for i := 0; i \u003c 10; i++ {\n        go increment()\n    }\n    time.Sleep(1 * time.Second)\n    fmt.Println(count)\n}\n```\n\n**Has race?** ____  \n**Type?** ____  \n**Why?** ____\n\n\u003cdetails\u003e\n\u003csummary\u003eSolution\u003c/summary\u003e\n\n**Has race?** YES  \n**Type?** Write-Write race (read-modify-write on count)  \n**Why?** Multiple goroutines executing `count++` (which is READ-ADD-WRITE)  \n**Fix?** Use `sync.Mutex`, channels, or `atomic.AddInt64`\n\n\u003c/details\u003e\n\n### Example 2\n\n```go\nvar message = \"Hello\"\n\nfunc main() {\n    for i := 0; i \u003c 5; i++ {\n        go func() {\n            fmt.Println(message)\n        }()\n    }\n    time.Sleep(1 * time.Second)\n}\n```\n\n**Has race?** ____  \n**Type?** ____  \n**Why?** ____\n\n\u003cdetails\u003e\n\u003csummary\u003eSolution\u003c/summary\u003e\n\n**Has race?** NO  \n**Type?** N/A  \n**Why?** All goroutines only READ `message`. No writes = no race!  \n**Note:** This is safe! Multiple concurrent readers are always OK.\n\n\u003c/details\u003e\n\n### Example 3\n\n```go\nfunc main() {\n    var x int\n    \n    go func() {\n        x = 1\n    }()\n    \n    go func() {\n        if x == 1 {\n            fmt.Println(\"x is 1\")\n        }\n    }()\n    \n    time.Sleep(1 * time.Second)\n}\n```\n\n**Has race?** ____  \n**Type?** ____  \n**Why?** ____\n\n\u003cdetails\u003e\n\u003csummary\u003eSolution\u003c/summary\u003e\n\n**Has race?** YES  \n**Type?** Read-Write race  \n**Why?** Goroutine 1 WRITES to x, Goroutine 2 READS x (in the if condition)  \n**Fix?** Use a channel to signal when x is ready, or protect x with a mutex\n\n\u003c/details\u003e\n\n### Example 4\n\n```go\nconst maxRetries = 3\n\nfunc retry() {\n    for i := 0; i \u003c maxRetries; i++ {\n        // ... do something\n    }\n}\n\nfunc main() {\n    go retry()\n    go retry()\n    time.Sleep(1 * time.Second)\n}\n```\n\n**Has race?** ____  \n**Type?** ____  \n**Why?** ____\n\n\u003cdetails\u003e\n\u003csummary\u003eSolution\u003c/summary\u003e\n\n**Has race?** NO  \n**Type?** N/A  \n**Why?** `maxRetries` is a const - it's never written after initialization. Multiple goroutines reading a const is safe!\n\n\u003c/details\u003e\n\n### Example 5\n\n```go\nvar cache = make(map[string]string)\n\nfunc get(key string) {\n    go func() {\n        value := cache[key]  // Read\n        fmt.Println(value)\n    }()\n}\n\nfunc set(key, value string) {\n    go func() {\n        cache[key] = value  // Write\n    }()\n}\n\nfunc main() {\n    go get(\"user\")\n    go set(\"user\", \"Alice\")\n    time.Sleep(1 * time.Second)\n}\n```\n\n**Has race?** ____  \n**Type?** ____  \n**Why?** ____\n\n\u003cdetails\u003e\n\u003csummary\u003eSolution\u003c/summary\u003e\n\n**Has race?** YES  \n**Type?** Map race (Read-Write on map)  \n**Why?** One goroutine reads from map while another writes. Go will panic: \"concurrent map read and map write\"  \n**Fix?** Protect map with `sync.RWMutex` or use `sync.Map`\n\n\u003c/details\u003e\n\n### Example 6\n\n```go\ntype Counter struct {\n    value int\n}\n\nvar c = \u0026Counter{value: 0}\n\nfunc main() {\n    for i := 0; i \u003c 10; i++ {\n        go func() {\n            c.value++\n        }()\n    }\n    time.Sleep(1 * time.Second)\n    fmt.Println(c.value)\n}\n```\n\n**Has race?** ____  \n**Type?** ____  \n**Why?** ____\n\n\u003cdetails\u003e\n\u003csummary\u003eSolution\u003c/summary\u003e\n\n**Has race?** YES  \n**Type?** Write-Write race (read-modify-write)  \n**Why?** Multiple goroutines doing `c.value++` which is READ-ADD-WRITE  \n**Fix?** Add a `sync.Mutex` to the Counter struct and protect the increment\n\n\u003c/details\u003e\n\n### Example 7\n\n```go\nvar ready bool\nvar data int\n\nfunc writer() {\n    data = 42\n    ready = true\n}\n\nfunc reader() {\n    for !ready {\n        // Wait\n    }\n    fmt.Println(data)\n}\n\nfunc main() {\n    go writer()\n    go reader()\n    time.Sleep(1 * time.Second)\n}\n```\n\n**Has race?** ____  \n**Type?** ____  \n**Why?** ____\n\n\u003cdetails\u003e\n\u003csummary\u003eSolution\u003c/summary\u003e\n\n**Has race?** YES - TWO RACES!  \n**Type?** Read-Write races (on both `ready` and `data`)  \n**Why?** \n- writer writes to `ready`, reader reads it (race #1)\n- writer writes to `data`, reader reads it (race #2)\n- Even worse: memory visibility! Reader might see ready=true but data=0!\n\n**Fix?** Use a channel to signal when data is ready, or protect both with a mutex\n\n\u003c/details\u003e\n\n### Example 8\n\n```go\nvar items = []int{1, 2, 3}\n\nfunc main() {\n    go func() {\n        fmt.Println(len(items))  // Read length\n    }()\n    \n    go func() {\n        items = append(items, 4)  // Might change length!\n    }()\n    \n    time.Sleep(1 * time.Second)\n}\n```\n\n**Has race?** ____  \n**Type?** ____  \n**Why?** ____\n\n\u003cdetails\u003e\n\u003csummary\u003eSolution\u003c/summary\u003e\n\n**Has race?** YES  \n**Type?** Slice header race (Read-Write)  \n**Why?** \n- Reading len(items) reads the slice header (pointer, len, cap)\n- append might modify the slice header (new backing array, new len, new cap)\n- Reading while modifying = race!\n\n**Fix?** Protect the slice with a mutex\n\n\u003c/details\u003e\n\n### Example 9\n\n```go\nfor i := 0; i \u003c 3; i++ {\n    go func() {\n        fmt.Println(i)\n    }()\n}\ntime.Sleep(1 * time.Second)\n```\n\n**Has race?** ____  \n**Type?** ____  \n**Why?** ____\n\n\u003cdetails\u003e\n\u003csummary\u003eSolution\u003c/summary\u003e\n\n**Has race?** YES  \n**Type?** Read-Write race (loop variable)  \n**Why?** \n- Loop writes to `i` (incrementing each iteration)\n- Goroutines read `i` (in fmt.Println)\n- All goroutines share the same `i` variable!\n\n**Result:** Might print \"3 3 3\" or \"2 3 3\" or other weird combinations  \n**Fix?** Pass `i` as parameter: `go func(n int) { fmt.Println(n) }(i)`\n\n\u003c/details\u003e\n\n### Example 10 (Hardest!)\n\n```go\nvar config interface{} = \"localhost:8080\"\n\nfunc main() {\n    go func() {\n        config = \"localhost:9090\"\n    }()\n    \n    go func() {\n        c := config.(string)\n        fmt.Println(c)\n    }()\n    \n    time.Sleep(1 * time.Second)\n}\n```\n\n**Has race?** ____  \n**Type?** ____  \n**Why?** ____\n\n\u003cdetails\u003e\n\u003csummary\u003eSolution\u003c/summary\u003e\n\n**Has race?** YES  \n**Type?** Interface race (Read-Write)  \n**Why?** \n- Interfaces are two words: (type pointer, data pointer)\n- Goroutine 1 writes both words\n- Goroutine 2 reads both words\n- Could see type from one write with data from another = CORRUPTION!\n\n**Danger level:** EXTREME - can break memory safety!  \n**Fix?** Protect with mutex or use proper synchronization\n\n\u003c/details\u003e\n\n---\n\n## Summary of Part 3\n\n**What you learned**:\n\n‚úÖ **`counter++` is 3 operations**: READ, ADD, WRITE  \n‚úÖ **Lost Update Problem**: Both read same value, one write disappears  \n‚úÖ **Memory \u0026 Caches**: Each CPU core has its own copy of data  \n‚úÖ **Three Conditions**: Multiple goroutines + Write + No sync = RACE  \n‚úÖ **Race Types**: Write-Write, Read-Write, Map races, Interface races  \n‚úÖ **Practice**: Identified races in 10 real examples  \n\n**Key insights**:\n\nüí° Simple-looking operations aren't atomic  \nüí° Writes don't instantly become visible  \nüí° Reads without synchronization can see stale data  \nüí° Maps and interfaces have special dangers  \nüí° The race detector is your friend  \n\n**What's next**:\n\nYou now understand WHY races happen. Parts 4-6 teach HOW to fix them:\n- **Part 4**: Channels (share by communicating)\n- **Part 5**: Mutexes (mutual exclusion locks)\n- **Part 6**: Atomics (CPU-level atomic operations)\n\nEach solution prevents races in different ways. You'll learn when to use each!\n\n**Ready to learn the solutions?** ‚Üí\n\n[Continue to Part 4: Solution #1 - Channels](./PART4_SOLUTION_CHANNELS.md)\n";
var __STRUCTURE__ = {"title":"Go Concurrency Mastery","overview":[{"id":"COMPLETE_COURSE_CURRICULUM","title":"Go Concurrency Mastery: Complete Course Curriculum","filename":"COMPLETE_COURSE_CURRICULUM.md"}],"chapters":[{"id":"chapter-01","title":"Chapter 01: The Race Condition Crisis","dir":"chapter-01","parts":[{"id":"PART0_INTRODUCTION","title":"Chapter 1, Part 0: Introduction and Setup","filename":"PART0_INTRODUCTION.md"},{"id":"PART1_SEQUENTIAL_BASELINE","title":"Chapter 1, Part 1: The Sequential Baseline","filename":"PART1_SEQUENTIAL_BASELINE.md"},{"id":"PART3_RACE_CONDITIONS_DEEP_DIVE","title":"Chapter 1, Part 3: What IS a Race Condition? - Deep Dive","filename":"PART3_RACE_CONDITIONS_DEEP_DIVE.md"},{"id":"PART4_SOLUTION_CHANNELS","title":"Chapter 1, Part 4: Solution #1 - Channels","filename":"PART4_SOLUTION_CHANNELS.md"},{"id":"PART4-1CHANNELS_PRACTICE","title":"Channels Practice","filename":"PART4-1CHANNELS_PRACTICE.md"}]}]};
</script>
<script src="../app.js"></script>
</body>
</html>